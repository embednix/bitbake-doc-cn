\newchapter{Syntax and Operators}{语法与运算符}


BitBake files have their own syntax. The syntax has similarities to several other languages but also has some unique features. This section describes the available syntax and operators as well as provides examples.

BitBake 文件有自己的特定语法。该语法与其他几种编程语言有相似之处，但也有一些独特的功能。本章将介绍 Bitbake 现有的语法和运算符，并提供一些参考示例。

\newsection{Basic Syntax}{基本语法}

This section provides some basic syntax examples.

本节提供了一些基本的语法示例。


\newsubsection{Basic Variable Setting}{基本变量设置}
\label{section:Basic Variable Setting}
The following example sets \code{VARIABLE} to ``value''. This assignment occurs immediately as the statement is parsed. It is a ``hard'' assignment\footnotemark[1].

以下示例用来设置 \code{VARIABLE} 为 ``value''。该赋值是在此语句被解析时立即进行的。这是一种``强硬''的赋值操作\footnotemark[1]。
\footnotetext[1]{此处的 ``hard'' 实际上有 ``硬编码(hard-coded)'' 的意思，就是说这个变量被赋予了一个常量值，但是并不意味此变量是一个不可更改的常数变量。}

\begin{pyglist}
VARIABLE = "value"
\end{pyglist}

As expected, if you include leading or trailing spaces as part of an assignment, the spaces are retained:

如果你在赋值中包含前导或尾随空格，则正如所预期的那样，这些空格将被保留在赋值中：

\begin{pyglist}
VARIABLE = " value"
VARIABLE = "value "
\end{pyglist}

Setting \code{VARIABLE} to \code{“”} sets it to an empty string, while setting the variable to \code{" "}  sets it to a blank space (i.e. these are not the same values).

如果设置 \code{VARIABLE} 为 \code{""} 会将其值设为空字符串，而将变量设置为 \code{" "}则将其设置为空格（这两者是完全不同的值）。

\begin{pyglist}
VARIABLE = ""
VARIABLE = " "
\end{pyglist}

You can use single quotes instead of double quotes when setting a variable's value. Doing so allows you to use values that contain the double quote character:

设置变量值时可以使用单引号而不是双引号。这样做允许你使用包含双引号字符的字符串值：

\begin{pyglist}
VARIABLE = 'I have a " in my value'
\end{pyglist}

\begin{noteblock}{Note}%
Unlike in Bourne shells, single quotes work identically to double quotes in all other ways. They do not suppress \bbsections{Variable Expansion}{variable expansions}.

\medskip
与 Bourne shell 不同，单引号在所有其他方面的工作方式都与双引号相同。它们并不会对\bbsections{Variable Expansion}{变量扩展}进行抑制。
\end{noteblock}

\newsubsection{Modifying Existing Variables}{修改现有变量}

Sometimes you need to modify existing variables. Following are some cases where you might find you want to modify an existing variable:

有时间我们需要修改现有变量的值。在下面所列的一些情况下，你可能会发现需要修改现有变量的值：

\begin{itemize}
\setlength\itemsep{1.0em}
\item Customize a recipe that uses the variable.

\medskip
对使用了该变量的配方进行定制。

\item Change a variable's default value used in a \code{*.bbclass} file.

\medskip
更改 \code{*.bbclass} 文件中所使用的变量的默认值。

\item Change the variable in a \code{*.bbappend} file to override the variable in the original recipe.

\medskip
更改 \code{*.bbappend} 文件中的变量的值用以重写原始配方中的变量的值。

\item Change the variable in a configuration file so that the value overrides an existing configuration.

\medskip
更改配置文件中的变量值，以便用新值重写现有配置文件中的旧值。
\end{itemize}

Changing a variable value can sometimes depend on how the value was originally assigned and also on the desired intent of the change. In particular, when you append a value to a variable that has a default value, the resulting value might not be what you expect. In this case, the value you provide might replace the value rather than append to the default value.

更改变量值有时取决于该值最初的赋值方式以及对其更改的预期意图。特别是，当你将新值附加到具有默认值的变量时，变量的最终的结果值可能并不是你所期望的。在这种情况下，你提供的值可能会替掉该变量的默认值，而不是将新值附加到默认值上去。

If after you have changed a variable's value and something unexplained occurs, you can use BitBake to check the actual value of the suspect variable. You can make these checks for both configuration and recipe level changes:

如果在你更改变量的值后出现一些无法解释的情况，你可以使用 BitBake 检查这些可疑变量的实际值。你可以在配置文件和配方文件的级别上对这些变量进行检查：

\begin{itemize}
\setlength\itemsep{1.0em}
\item For configuration changes, use the following:

\medskip
对于配置的更改，请使用以下命令：

\medskip
\begin{pyglist}
$ bitbake -e
\end{pyglist}

\medskip
This command displays variable values after the configuration files (i.e. \code{local.conf}, \code{bblayers.conf}, \code{bitbake.conf} and so forth) have been parsed.

\medskip
该命令在解析相关的配置文件（即 \code{local.conf}, \code{bblayers.conf}, \code{bitbake.conf} 等）后会显示所有的变量的值。

\medskip
\begin{noteblock}{Note}%
Variables that are exported to the environment are preceded by the string ``export'' in the command's output.

\medskip
在此命令的输出中，导出到环境的变量前面带有字符串``export''。

\end{noteblock}

\item To find changes to a given variable in a specific recipe, use the following:

\medskip
要查找特定配方中给定变量的更改，请使用以下命令：

\medskip
\begin{pyglist}
$ bitbake recipename -e | grep VARIABLENAME=\"
\end{pyglist}

\medskip
This command checks to see if the variable actually makes it into a specific recipe.

\medskip
此命令可以检查此变量是否被特定配方所使用。

\end{itemize}

\newsubsection{Line Joining}{行的连接}

Outside of \bbsections{Functions}{functions}, BitBake joins any line ending in a backslash character (``\textbackslash'') with the following line before parsing statements. The most common use for the ``\textbackslash'' character is to split variable assignments over multiple lines, as in the following example:

在\bbsections{Functions}{函数}定义之外的代码中，BitBake 在解析语句之前会将任何以反斜杠字符 (``\textbackslash'') 结尾的行与下一行连接起来。 ``\textbackslash'' 字符最常见的用途就是将变量分配拆分为多行代码，如下例所示：

\begin{pyglist}
FOO = "bar \
       baz \
       qaz"
\end{pyglist}

Both the ``\textbackslash'' character and the newline character that follow it are removed when joining lines. Thus, no newline characters end up in the value of \code{FOO}.

在进行行连接时，``\textbackslash''字符及其后面的换行符都会被删除。因此， 变量 \code{FOO} 的值中不会出现换行符。

Consider this additional example where the two assignments both assign ``barbaz'' to \code{FOO}:

下面这个附加示例展示了将``barbaz''分配给变量 \code{FOO} 的两种赋值方式：

\begin{pyglist}
FOO = "barbaz"
FOO = "bar\
baz"
\end{pyglist}

\begin{noteblock}{Note}%
BitBake does not interpret escape sequences like ``\textbackslash n'' in variable values. For these to have an effect, the value must be passed to some utility that interprets escape sequences, such as \code{printf} or \code{echo -n}.

\medskip
BitBake 不会解释变量值中的 ``\textbackslash n'' 等转义字符序列。为了使这些转义字符生效，必须将变量值传递给一些能够解释转义字符序列的实用程序，例如 \code{printf} 或者 \code{echo -n} 等。
\end{noteblock}


\newsubsection{Variable Expansion}{变量扩展}
\label{section:Variable Expansion}

Variables can reference the contents of other variables using a syntax that is similar to variable expansion in Bourne shells. The following assignments result in A containing ``aval'' and B evaluating to ``preavalpost''.

变量可以使用类似于 Bourne shell 中的变量扩展的语法来引用其他变量的内容。以下赋值的结果是 A 的值是 ``aval''，B 的最终计算结果为 ``preavalpost''。

\begin{pyglist}
A = "aval"
B = "pre${A}post"
\end{pyglist}

\begin{noteblock}{Note}%
Unlike in Bourne shells, the curly braces are mandatory: Only \code{${FOO}} and not \code{$FOO} is recognized as an expansion of \code{FOO}.

\medskip
与 Bourne shell 不同，在引用别的变量时，用以包含变量的花括号是强制性的：只有 \code{${FOO}}, 而不是 \code{$FOO} 可以被识别为 \code{FOO} 的扩展。
\end{noteblock}

The ``='' operator does not immediately expand variable references in the right-hand side. Instead, expansion is deferred until the variable assigned to is actually used. The result depends on the current values of the referenced variables. The following example should clarify this behavior:

``='' 运算符不会立即对右侧的变量进行变量展开引用。相反，对所引用的变量的展开会被推迟到所分配给的变量被实际使用的那一刻为止。变量展开的最终结果取决于所引用的变量的当前值。以下示例应改能够阐明这种行为：

\begin{pyglist}
A = "${B} baz"
B = "${C} bar"
C = "foo"
*At this point, ${A} equals "foo bar baz"*
C = "qux"
*At this point, ${A} equals "qux bar baz"*
B = "norf"
*At this point, ${A} equals "norf baz"*
\end{pyglist}

Contrast this behavior with the \bbsection{Immediate variable expansion (:=)} operator.

与此行为相反的是\bbsections{Immediate variable expansion (:=)}{立即变量展开 (:=)}运算符。

If the variable expansion syntax is used on a variable that does not exist, the string is kept as is. For example, given the following assignment, \code{BAR} expands to the literal string ``\$\{FOO\}''\footnotemark[1] as long as \code{FOO} does not exist.

如果对不存在的变量使用变量扩展语法，则原变量赋值的字符串将保持原样不变。例如，给定以下赋值代码，变量 BAR 的赋值在不存在变量 \code{FOO} 的情况下，就会扩展为存粹的文字字符串 ``\$\{FOO\}''\footnotemark[1]。

\footnotetext[1]{也就是说在不存变量 \code{FOO} 的情况下，变量 \code{BAR} 的值中的 `\textdollar'，`\{' 和 `\}' 都是普通的字符，而不是特殊的需要转义的字符；``FOO'' 也只是一个普通的字符串。}

\begin{pyglist}
BAR = "${FOO}"
\end{pyglist}

\newsubsection{Setting a default value (?=)}{设置默认值(?=)}

You can use the ``?='' operator to achieve a ``softer''\footnotemark[2] assignment for a variable. This type of assignment allows you to define a variable if it is undefined when the statement is parsed, but to leave the value alone if the variable has a value. Here is an example:

你可以使用 ``?='' 运算符来实现变量的``更软''\footnotemark[2]赋值。这种类型的赋值允许 BitBake 在解析此语句时对那些尚未被定义的变量进行定义。但是如果此时变量已经被定义了一个值，则此变量的赋值将保持不变。参见下面例子：

\footnotetext[2]{这是相对前面所说的“强硬”的赋值操作而言。请参考\bbsections{Basic Variable Setting}{基本变量设置}。}
\begin{pyglist}
A ?= "aval"
\end{pyglist}

If A is set at the time this statement is parsed, the variable retains its value. However, if A is not set, the variable is set to ``aval''.

如果变量A在解析该语句时已经被赋值了 ，则该变量的赋值将保持不变；但是如果A未被赋值，则该变量的赋值将被设置为``aval''。

\begin{noteblock}{Note}%
This assignment is immediate. Consequently, if multiple ``?='' assignments to a single variable exist, the first of those ends up getting used.

\medskip
此赋值任务是立即被执行的。因此，如果存在对单个变量的多个 ``?='' 赋值操作，则只有第一个操作的赋值会被最终采用。
\end{noteblock}


\newsubsection{Setting a weak default value (??=)}{设置弱默认值(??=)}

The weak default value of a variable is the value which that variable will expand to if no value has been assigned to it via any of the other assignment operators. The ``??='' operator takes effect immediately, replacing any previously defined weak default value. Here is an example:

变量的弱默认值是在没有通过任何其他赋值运算符为该变量赋值的情况下该变量将扩展为的值。 ``??='' 运算符是立即生效的赋值操作，此操作会替换任何先前所定义的弱默认值。参见下面例子：

\begin{pyglist}
W ??= "x"
A := "${W}" # Immediate variable expansion
W ??= "y"
B := "${W}" # Immediate variable expansion
W ??= "z"
C = "${W}"
W ?= "i"
\end{pyglist}

After parsing we will have:

解析后我们将得到：

\begin{pyglist}
A = "x"
B = "y"
C = "i"
W = "i"
\end{pyglist}

Appending and prepending non-override style will not substitute the weak default value, which means that after parsing:

附加和前置的非重写式的赋值操作不会替换弱默认值，这意味着解析后：

\begin{pyglist}
W ??= "x"
W += "y"
\end{pyglist}

we will have:

我们会得到：

\begin{pyglist}
W = " y"
\end{pyglist}

On the other hand, override-style appends/prepends/removes are applied after any active weak default value has been substituted:

另一方面，在替换任何活动的弱默认值之后，将应用重写式附加/前置/删除：

\begin{pyglist}
W ??= "x"
W:append = "y"
\end{pyglist}

After parsing we will have:

解析后我们将得到：


\begin{pyglist}
W = "xy"
\end{pyglist}

\subsection{Immediate variable expansion (:=)}
\label{section:Immediate variable expansion (:=)}

The ``:='' operator results in a variable's contents being expanded immediately, rather than when the variable is actually used:

``:=''运算符会导致变量的内容立即展开，而不是在变量在被实际使用时展开：

\begin{pyglist}
T = "123"
A := "test ${T}"
T = "456"
B := "${T} ${C}"
C = "cval"
C := "${C}append"
\end{pyglist}

In this example, \code{A} contains ``test 123'', even though the final value of \code{T} is ``456''. The variable \code{B} will end up containing ``456 cvalappend''. This is because references to undefined variables are preserved as is during (immediate)expansion. This is in contrast to GNU Make, where undefined variables expand to nothing. The variable \code{C} contains ``cvalappend'' since \code{${C}} immediately expands to ``cval''.

在此示例中，即使变量 \code{T} 的最终值为``456'', \code{A} 的值也是 ``test 123''。变量 \code{B} 最终值将是 ``456 cvalappend''。这是因为对未定义变量的引用在（立即）扩展期间是按原样进行保留。这一点是与 GNU Make 形成鲜明区别，GNU Make 中对未定义的变量会扩展为空字符串。变量 \code{C} 的最终值为 ``cvalappend''，因为 \code{${C}} 被立即扩展为 ``cval''。

\newsubsection{Appending (+=) and prepending (=+) With Spaces}{自带空格的附加 (.=) 和前置 (=.)}

Appending and prepending values is common and can be accomplished using the ``+='' and ``=+'' operators. These operators insert a space between the current value and prepended or appended value.

附加和前置值很常见，可以使用 ``+='' 和 ``=+'' 运算符来完成。这些运算符会在当前值和前置或附加值之间插入一个空格。

These operators take immediate effect during parsing. Here are some examples:

这些运算符在解析期间会立即生效。参见下面的这些例子：

\begin{pyglist}
B = "bval"
B += "additionaldata"
C = "cval"
C =+ "test"
\end{pyglist}

The variable \code{B} contains ``bval additionaldata'' and \code{C} contains ``test cval''.

变量 \code{B} 的值是 ``bval extradata''，变量 \code{C} 的值是 ``test cval''。

\newsubsection{Appending (.=) and Prepending (=.) Without Spaces}{无空格的附加 (.=) 和前置 (=.)}

If you want to append or prepend values without an inserted space, use the ``.='' and ``=.'' operators.

如果要在不插入空格的情况下附加或前置值，请使用``.='' 和 ``=.'' 运算符。

These operators take immediate effect during parsing. Here are some examples:

这些运算符在解析期间会立即生效。参见下面的这些例子：

\begin{pyglist}
B = "bval"
B .= "additionaldata"
C = "cval"
C =. "test"
\end{pyglist}

The variable \code{B} contains ``bvaladditionaldata'' and C contains ``testcval''.

变量 \code{B} 的值是 ``bvaladditionaldata''，变量 \code{C} 的值是 ``testcval''。

\newsubsection{Appending and Prepending (Override Style Syntax)}{附加和前置（重写样式语法）}

You can also append and prepend a variable's value using an override style syntax. When you use this syntax, no spaces are inserted.

你还可以使用重写式语法来对变量来附加和前置新的值。使用此语法时，不会插入空格。

These operators differ from the ``:='', ``.='', ``=.'', ``+='', and ``=+'' operators in that their effects are applied at variable expansion time rather than being immediately applied. Here are some examples:

这些运算符与``:=''，``.=''，``=.''，``+='' 和 ``=+'' 运算符的不同之处在于，它们是在变量扩展时才起作用，而不是立即作用。参见下面的这些例子：

\begin{pyglist}
B = "bval"
B:append = " additional data"
C = "cval"
C:prepend = "additional data "
D = "dval"
D:append = "additional data"
\end{pyglist}

The variable \code{B} becomes ``bval additional data'' and \code{C} becomes ``additional data cval''. The variable \code{D} becomes ``dvaladditional data''.

变量 \code{B} 成为 ``bval additional data''；变量 \code{C} 成为 ``additional data cval''；变量 \code{D} 成为 ``dvaladditional data''.

\begin{noteblock}{Note}%
You must control all spacing when you use the override syntax.

\medskip
在使用这些重写性的语法时你必须自己控制空格键。
\end{noteblock}

\begin{noteblock}{Note}%
The overrides are applied in this order, ``:append'', ``:prepend'', ``:remove''.

\medskip
对原有变量值的重写是按以下顺序来应用的：``:append''、``:prepend''、``:remove''。
\end{noteblock}

It is also possible to append and prepend to shell functions and BitBake-style Python functions. See the ``\bbsection{Shell Functions}'' and ``\bbsection{BitBake-Style Python Functions}'' sections for examples.

对 shell 函数和 BitBake 风格的 Python 函数也可以进行附加和前置操作。有关示例请参阅 ``\bbsection{Shell Functions}'' 和 ``\bbsection{BitBake-Style Python Functions}'' 部分。

\newsubsection{Removal (Override Style Syntax)}{删除（重写式语法）}

You can remove values from lists using the removal override style syntax. Specifying a value for removal causes all occurrences of that value to be removed from the variable. Unlike ``:append'' and ``:prepend'', there is no need to add a leading or trailing space to the value.

你可以使用删除重写式语法从一些列表中删除一些值。在指定要删除的值的情况下，变量中所包含的所有出现的相同值都会被删除掉。与``:append'' 和 ``:prepend'' 不同，不需要在要删除的值中添加前导或尾随空格。

When you use this syntax, BitBake expects one or more strings. Surrounding spaces and spacing are preserved. Here is an example:

当你使用此语法时，BitBake 需要一个或多个字符串作为输入。在变量值剩下的部分中，其周围的空格被保留下来。这是一个例子：

\begin{pyglist}
FOO = "123 456 789 123456 123 456 123 456"
FOO:remove = "123"
FOO:remove = "456"
FOO2 = " abc def ghi abcdef abc def abc def def"
FOO2:remove = "\
    def \
    abc \
    ghi \
    "
\end{pyglist}

The variable \code{FOO} becomes ``\textvisiblespace 789 123456\textvisiblespace'' and \code{FOO2} becomes ``\textvisiblespace abcdef\textvisiblespace''.

变量 \code{FOO} 成为 ``\textvisiblespace 789 123456\textvisiblespace''，而变量 \code{FOO2} 成为 ``\textvisiblespace abcdef\textvisiblespace''.

Like ``:append'' and ``:prepend'', ``:remove'' is applied at variable expansion time.

与 ``:append'' 和 ``:prepend'' 类似，``:remove'' 也是在进行变量展开的时间来应用的。

\begin{noteblock}{Note}%
The overrides are applied in this order, ``:append'', ``:prepend'', ``:remove''. This implies it is not possible to re-append previously removed strings. However, one can undo a ``:remove'' by using an intermediate variable whose content is passed to the ``:remove'' so that modifying the intermediate variable equals to keeping the string in:

\medskip
对变量值的重写按以下顺序来应用的：``:append'', ``:prepend'', ``:remove''。这意味着不可能将之前删除的字符串再重新附加回到变量的赋值上去。然而，可以通过使用中间变量来撤消 ``:remove'' 操作，该中间变量的内容被传递给 ``:remove''，这样就只需要修改中间变量就能将字符串保留在当前值中：

\medskip
\begin{pyglist}
FOOREMOVE = "123 456 789"
FOO:remove = "${FOOREMOVE}"
...
FOOREMOVE = "123 789"
\end{pyglist}

\medskip
This expands to \code{FOO:remove = "123 789"}.

\medskip
由于 ``:remove'' 操作是最后被应用的，这样做的结果就是 \code{FOO:remove} 被扩展为 \code{FOO:remove = "123 789"}
\end{noteblock}

\begin{noteblock}{Note}%
Override application order may not match variable parse history, i.e. the output of \code{bitbake -e} may contain ``:remove'' before ``:append'', but the result will be removed string, because ``:remove'' is handled last.

\medskip
重写操作的应用顺序可能与变量解析的历史顺序不相匹配，即 \code{bitbake -e} 的输出可能在 ``:append'' 之前包含 ``:remove''，但是最终结果还是将当前值中的一些字符串删除掉了，这是因为 ``:remove'' 操作是最后被处理的。
\end{noteblock}

\newsubsection{Override Style Operation Advantages}{重写式操作的优点}

An advantage of the override style operations ``:append'', ``:prepend'', and ``:remove'' as compared to the ``+='' and ``=+'' operators is that the override style operators provide guaranteed operations. For example, consider a class  \code{foo.bbclass}  that needs to add the value ``val'' to the variable \code{FOO}, and a recipe that uses  \code{foo.bbclass}  as follows:

与 ``+='' 和 ``=+'' 运算符相比，重写式操作 ``:append''、``:prepend'' 和 ``:remove'' 的优点是重写式运算符能够提供有保证的操作。例如，考虑一个类文件 \code{foo.bbclass} 需要将值 ``val'' 添加到变量 \code{FOO} 中，而一个配方文件采用下面的方式来使用类文件 \code{foo.bbclass}：

\begin{pyglist}
inherit foo
FOO = "initial"
\end{pyglist}

If  \code{foo.bbclass}  uses the ``+='' operator, as follows, then the final value of \code{FOO} will be ``initial'', which is not what is desired:

如果文件 \code{foo.bbclass} 是使用 ``+='' 运算符，那么变量 \code{FOO} 的最终值将会是 ``initial''，而这根本不是我们想要的结果。

\begin{pyglist}
FOO += "val"
\end{pyglist}

If, on the other hand,  \code{foo.bbclass}  uses the ``:append'' operator, then the final value of \code{FOO} will be ``initial val'', as intended:

另一方面，如果 \code{foo.bbclass} 是使用 ``:append'' 运算符，则变量 \code{FOO} 的最终值将是 ``initial val''，如下所示：

\begin{pyglist}
FOO:append = " val"
\end{pyglist}

\begin{noteblock}{Note}%
It is never necessary to use ``+='' together with ``:append''. The following sequence of assignments appends ``barbaz'' to \code{FOO}:

\medskip
从来就没有必要将 ``+='' 与 ``:append'' 一起使用。以下的赋值顺序会将 ``barbaz'' 附加到变量 \code{FOO} 上：

\medskip
\begin{pyglist}
FOO:append = "bar"
FOO:append = "baz"
\end{pyglist}

\medskip
The only effect of changing the second assignment in the previous example to use ``+='' would be to add a space before ``baz'' in the appended value (due to how the ``+='' operator works).

\medskip
将上一个示例中的第二个赋值运算符更改为使用 ``+='' 的唯一效果是在附加值中的 ``baz'' 之前添加一个空格，这是由 ``+='' 运算符的工作方式决定的。
\end{noteblock}

Another advantage of the override style operations is that you can combine them with other overrides as described in the ``\bbsection{Conditional Syntax (Overrides)}'' section.

重写式操作符的另一个优点是你可以将它们与其他重写操作结合起来使用，请参见 ``\bbsections{Conditional Syntax (Overrides)}{条件语法（重写）}'' 部分中所述。


\newsubsection{Variable Flag Syntax}{变量标志语法}
\label{section:Variable Flag Syntax}

Variable flags are BitBake's implementation of variable properties or attributes. It is a way of tagging extra information onto a variable. You can find more out about variable flags in general in the ``\bbsection{Variable Flags}'' section.

变量标志是 BitBake 对各种变量的属性或者特性的实现。这是一种将额外信息标记到变量上的方法。你可以在 ``\bbsections{Variable Flags}{变量标志}'' 部分中找到有关变量标志的更多信息。


You can define, append, and prepend values to variable flags. All the standard syntax operations previously mentioned work for variable flags except for override style syntax (i.e. ``:prepend'', ``:append'', and ``:remove'').

你可以为变量标志定义、附加和前置值。前面提到的所有标准语法，除了重写式语法（即``:prepend''、``:append'' 和 ``:remove''）之外的所有操作都适用于变量标志。

Here are some examples showing how to set variable flags:

下面这些例子展示了怎样设置变量标志：

\begin{pyglist}
FOO[a] = "abc"
FOO[b] = "123"
FOO[a] += "456"
\end{pyglist}

The variable \code{FOO} has two flags: \code{[a]} and \code{[b]}. The flags are immediately set to ``abc'' and ``123'', respectively. The \code{[a]} flag becomes ``abc 456''.

该变量 \code{FOO} 有两个标志： [a] 和 [b]。这两个标志立即分别设置为 ``abc'' 和 ``123''。标志[a]最后变为 ``abc 456''。

No need exists to pre-define variable flags. You can simply start using them. One extremely common application is to attach some brief documentation to a BitBake variable as follows:

变量标志无需预先定义就可以开始使用它们。一种极其常见的应用是将一些简短的文档附加到 BitBake 的变量上，如下面的例子所示：

\begin{pyglist}
CACHE[doc] = "The directory holding the cache of the metadata."
\end{pyglist}

\begin{noteblock}{Note}%
Variable flag names starting with an underscore (\_) character are allowed but are ignored by \code{d.getVarFlags("VAR")} in Python code. Such flag names are used internally by BitBake.

\medskip
变量标志的名称允许以下划线 (\_) 字符开头，但是会被 Python 代码中的 \code{d.getVarFlags("VAR")} 调用所忽略。一般此类变量标志的名称都是由 BitBake 内部使用。
\end{noteblock}

\newsubsection{Inline Python Variable Expansion}{内联Python变量扩展}
\label{section:Inline Python Variable Expansion}

You can use inline Python variable expansion to set variables. Here is an example:

你可以使用内联 Python 变量扩展来设置变量。参见下面的例子：

\begin{pyglist}
DATE = "${@time.strftime('%Y%m%d',time.gmtime())}"
\end{pyglist}

This example results in the \code{DATE} variable being set to the current date.

此例是将变量 \code{DATE} 设置为当前日期。

Probably the most common use of this feature is to extract the value of variables from BitBake's internal data dictionary, \code{d}. The following lines select the values of a package name and its version number, respectively:

此功能最常见的用途是从 BitBake 的内部数据字典中提取变量的值\code{d}。以下两行代码分别是用来选择软件包的名称及其版本号：

\begin{pyglist}
PN = "${@bb.parse.vars_from_file(d.getVar('FILE', False),d)[0] or 'defaultpkgname'}"
PV = "${@bb.parse.vars_from_file(d.getVar('FILE', False),d)[1] or '1.0'}"
\end{pyglist}

\begin{noteblock}{Note}%

Inline Python expressions work just like variable expansions insofar as the ``='' and ``:='' operators are concerned. Given the following assignment, foo() is called each time \code{FOO} is expanded:

\medskip
就 ``='' 和 ``:='' 运算符而言，内联 Python 表达式的工作方式与变量扩展类似。变量 \code{FOO} 如果是按照下面的例子给定赋值，则每次扩展 \code{FOO} 的时间，函数 \code{foo()} 都会被调用：

\medskip
\begin{pyglist}
FOO = "${@foo()}"
\end{pyglist}

\medskip
Contrast this with the following immediate assignment, where foo() is only called once, while the assignment is parsed:

\medskip
可以将此与下面的立即赋值的例子进行对比，下面的例子中，函数 \code{foo()} 仅仅在解析赋值的时间被调用一次：

\medskip
\begin{pyglist}
FOO := "${@foo()}"
\end{pyglist}
\end{noteblock}

For a different way to set variables with Python code during parsing, see the ``\bbsection{Anonymous Python Functions}'' section.

有关在解析期间如何使用 Python 代码来进行变量设置的其他方法，请参阅 ``\bbsections{Anonymous Python Functions}{匿名 Python 函数}‘’ 部分。

\newsubsection{Unsetting variables}{取消设置变量}

It is possible to completely remove a variable or a variable flag from BitBake's internal data dictionary by using the ``unset'' keyword. Here is an example:

通过使用 ``unset'' 关键字，可以从 BitBake 的内部数据字典中完全删除已经定义过的变量或变量标志。示例如下：

\begin{pyglist}
unset DATE
unset do_fetch[noexec]
\end{pyglist}

These two statements remove the DATE and the \code{do_fetch[noexec]} flag.

这两行代码会把变量 \code{DATE} 和变量标志 \code{do_fetch[noexec]} 都删除掉。

\newsubsection{Providing Pathnames}{提供路径名}

When specifying pathnames for use with BitBake, do not use the tilde (``\textasciitilde'')\footnotemark[1] character as a shortcut for your home directory. Doing so might cause BitBake to not recognize the path since BitBake does not expand this character in the same way a shell would.

在指定用于 BitBake 所使用的路径名称时，请勿使用波浪号（``\textasciitilde''）\footnotemark[1]字符作为主目录的快捷方式。这样做的结果是可能会导致 BitBake 无法识别该路径，因为 BitBake 不会像 shell 那样来扩展此字符。

\footnotetext[1]{在Linux系统中，\code{'~'} 是指用户的个人目录，shell 会将 \code{'~'} 扩展为 \code{/home/<user_name>}}

Instead, provide a fuller path as the following example illustrates:

相反，请提供更完整的绝对路径名，如下例所示：

\begin{pyglist}
BBLAYERS ?= " \
    /home/scott-lenovo/LayerA \
"
\end{pyglist}

\newsection{Exporting Variables to the Environment}{导出变量到运行环境中去}

You can export variables to the environment of running tasks by using the \code{export} keyword. For example, in the following example, the \code{do_foo} task prints ``value from the environment'' when run:

你可以使用关键字 \code{"export"} 将变量导出到运行任务的环境中去。例如在以下示例中，\code{do_foo} 任务会在运行时打印字符串 ``value from the environment''：

\begin{pyglist}
export ENV_VARIABLE
ENV_VARIABLE = "value from the environment"

do_foo() {
    bbplain "$ENV_VARIABLE"
}
\end{pyglist}

\begin{noteblock}{Note}%

BitBake does not expand \code{$ENV_VARIABLE} in this case because it lacks the obligatory \{\}\footnotemark[2] . Rather, \code{$ENV_VARIABLE} is expanded by the shell.

\medskip
BitBake 在这种情况下不会对 \code{$ENV_VARIABLE} 进行扩展，因为它缺乏强制性的\{\}\footnotemark[2]。相反，\code{$ENV_VARIABLE} 是由 shell 来进行扩展的。

\end{noteblock}

\footnotetext[2]{参见 \bbsections{Variable Expansion}{变量扩展} 章节部分}


It does not matter whether \code{export ENV_VARIABLE} appears before or after assignments to \code{ENV_VARIABLE}.

\code{export ENV_VARIABLE} 出现在对变量 \code{ENV_VARIABLE} 的赋值之前还是之后并不重要，不会影响其效果。

It is also possible to combine \code{export} with setting a value for the variable. Here is an example:

还可以将 \code{export} 与设置变量值结合在一起使用。示例如下：

\begin{pyglist}
export ENV_VARIABLE = "variable-value"
\end{pyglist}

In the output of \code{bitbake -e}, variables that are exported to the environment are preceded by ``export''.

在  \code{bitbake -e} 的输出中，导出到环境的变量前面带有前导字符 ``export''。

Among the variables commonly exported to the environment are \code{CC} and \code{CFLAGS}, which are picked up by many build systems.

常见的导出到环境的变量包括 \code{CC} 和 \code{CFLAGS}，许多构建系统都会把这两个变量输出到运行环境中去。

\newsection{Conditional Syntax (Overrides)}{条件性语法（重写）}
\label{section:Conditional Syntax (Overrides)}

BitBake uses \bbgls{OVERRIDES} to control what variables are overridden after BitBake parses recipes and configuration files. This section describes how you can use \bbgls{OVERRIDES} as conditional metadata, talks about key expansion in relationship to \bbgls{OVERRIDES}, and provides some examples to help with understanding.

BitBake 使用 \bbgls{OVERRIDES} 来控制 BitBake 解析配方和配置文件后需要重写的那些变量。本节介绍如何使用\linebreak \bbgls{OVERRIDES} 作为条件性的元数据，讨论与 \bbgls{OVERRIDES} 相关的关键扩展，并提供一些示例来帮助理解这些概念。


\newsubsection{Conditional Metadata}{条件性的元数据}

You can use \bbgls{OVERRIDES} to conditionally select a specific version of a variable and to conditionally append or prepend the value of a variable.

你可以使用 \bbgls{OVERRIDES} 有条件地选择变量的特定版本，并且有条件地对变量的值进行附加或添加。

\begin{noteblock}{Note}%
Overrides can only use lower-case characters, digits and dashes. In particular, colons are not permitted in override names as they are used to separate overrides from each other and from the variable name.

\medskip
要重写的项目的名称只能使用小写字符、数字和破折号。特别是重写的项目名称中不允许使用冒号，因为冒号是用于将不同重写项的名称和不同的变量名称进行分隔的。
\end{noteblock}

\begin{itemize}
\setlength\itemsep{1.0em}
\item \textbf{Selecting a Variable:} The \bbgls{OVERRIDES} variable is a colon-character-separated list that contains items for which you want to satisfy conditions. Thus, if you have a variable that is conditional on ``arm'', and ``arm'' is in \bbgls{OVERRIDES}, then the ``arm''-specific version of the variable is used rather than the non-conditional version. Here is an example:

\item \textbf{选择一个变量：} \bbgls{OVERRIDES} 变量是一个以冒号分隔的字符串的列表，列表中包含了要满足条件的项目名称。因此如果你有一个以 ``arm'' 为条件的变量，并且 ``arm'' 是存在于 \bbgls{OVERRIDES} 的列表之中的，则在使用改变量的时间，将只使用特定于 ``arm'' 的的那个版本的变量，而不是其他版本的相同变量。示例如下：

\begin{pyglist}
OVERRIDES = "architecture:os:machine"
TEST = "default"
TEST:os = "osspecific"
TEST:nooverride = "othercondvalue"
\end{pyglist}

In this example, the \bbgls{OVERRIDES} variable lists three overrides: ``architecture'', ``os'', and ``machine''. The variable TEST by itself has a default value of ``default''. You select the os-specific version of the \code{TEST} variable by appending the ``os'' override to the variable (i.e. \code{TEST:os}).

\medskip
在此示例中，\bbgls{OVERRIDES} 变量列出了三个要重写的项目：``architecture''、``os'' 和 ``machine''。变量 \code{TEST} 本身具有默认值为``default''，但是我们可以通过将 ``os'' 附加到变量 \code{TEST} 即 \code{TEST:os} 上来选择此变量的特定于 \code{os} 的版本。

\medskip
To better understand this, consider a practical example that assumes an OpenEmbedded metadata-based Linux kernel recipe file. The following lines from the recipe file first set the kernel branch variable \code{KBRANCH} to a default value, then conditionally override that value based on the architecture of the build:

\medskip
为了更好地理解这一点，请考虑下面一个真实的示例，该示例假设有一个基于 OpenEmbedded 元数据的 Linux 的内核配方文件。配方文件中的以下几行首先将内核分支变量 \code{KBRANCH} 设置为默认值，然后根据所要构建的体系结构的值进行有条件地重写该变量 \code{KBRANCH} 的值：

\medskip
\begin{pyglist}
KBRANCH = "standard/base"
KBRANCH:qemuarm = "standard/arm-versatile-926ejs"
KBRANCH:qemumips = "standard/mti-malta32"
KBRANCH:qemuppc = "standard/qemuppc"
KBRANCH:qemux86 = "standard/common-pc/base"
KBRANCH:qemux86-64 = "standard/common-pc-64/base"
KBRANCH:qemumips64 = "standard/mti-malta64"
\end{pyglist}

\item \textbf{Appending and Prepending:} BitBake also supports append and prepend operations to variable values based on whether a specific item is listed in \bbgls{OVERRIDES}. Here is an example:

\item \textbf{附加和前置:} BitBake 还支持根据 \bbgls{OVERRIDES} 中列出的特定项目来对变量值进行附加和前置操作。

\begin{pyglist}
DEPENDS = "glibc ncurses"
OVERRIDES = "machine:local"
DEPENDS:append:machine = "libmad"
\end{pyglist}

\medskip
In this example, \bbgls{DEPENDS}\footnotemark[1] becomes ``glibc ncurses libmad''.

\medskip
在上面的例子中，\bbgls{DEPENDS}\footnotemark[1] 变成了 ``glibc ncurses libmad''。

\medskip
\footnotetext[1]{此处应该是 \code{DEPENDS:machine}}

\medskip
Again, using an OpenEmbedded metadata-based kernel recipe file as an example, the following lines will conditionally append to the \code{KERNEL_FEATURES} variable based on the architecture:

\medskip
我们再次使用基于 OpenEmbedded 元数据的内核配方文件作为示例，以下代码将 \code{KERNEL_FEATURES} 根据目标架构的设定值（\code{qemux86} 和 \code{qemux86-64}）来有条件地将其他的值附加到原先变量的值上去：

\medskip
\begin{pyglist}
KERNEL_FEATURES:append = " ${KERNEL_EXTRA_FEATURES}"
KERNEL_FEATURES:append:qemux86=" cfg/sound.scc cfg/paravirt_kvm.scc"
KERNEL_FEATURES:append:qemux86-64=" cfg/sound.scc cfg/paravirt_kvm.scc"
\end{pyglist}

\item \textbf{Setting a Variable for a Single Task:} BitBake supports setting a variable just for the duration of a single task. Here is an example:
\item \textbf{为单个任务设置变量:} BitBake 支持仅在单个任务的运行时间之内来设置变量。示例如下：

\begin{pyglist}
FOO:task-configure = "val 1"
FOO:task-compile = "val 2"
\end{pyglist}

\medskip
In the previous example, \code{FOO} has the value ``val 1'' while the \code{do_configure} task is executed, and the value ``val 2'' while the \code{do_compile} task is executed.

\medskip
在前面的示例中，执行任务 \code{do_configure} 时，变量 \code{FOO} 的值为 ``val 1''；执行任务 \code{do_compile} 时其值则为 ``val 2''。

\medskip
Internally, this is implemented by prepending the task (e.g. ``task-compile:'') to the value of \bbgls{OVERRIDES} for the local datastore of the \code{do_compile} task.

\medskip
这是在BitBake内部，通过将任务名称（例如 ``\code{task-compile:}''）添加到任务的本地数据所存储的变量 \bbgls{OVERRIDES} 所代表的值中来实现的。

\medskip
You can also use this syntax with other combinations (e.g. ``\code{:prepend}'') as shown in the following example:

\medskip
你也可以将此语法与其他组合（例如 ``\code{:prepend}''）一起使用，如下例所示：

\medskip
\begin{pyglist}
EXTRA_OEMAKE:prepend:task-compile = "${PARALLEL_MAKE} "
\end{pyglist}

\end{itemize}

\begin{noteblock}{Note}%
Before BitBake 1.52 (Honister 3.4), the syntax for \bbgls{OVERRIDES} used \code{_} instead of \code{:}, so you will still find a lot of documentation using \code{_append}, \code{_prepend}, and \code{_remove}, for example.

\medskip
在 BitBake 1.52（Honister 3.4）版本之前， \bbgls{OVERRIDES} 的语法是使用 \code{_} 字符而不是 \code{:} 字符，因此你会发现很多文档仍然在使用 \code{_append}、\code{_prepend}和 \code{_remove}。

\medskip
For details, see the \href{https://docs.yoctoproject.org/migration-guides/migration-3.4.html#override-syntax-changes}{Overrides Syntax Changes} section in the Yocto Project manual migration notes.

\medskip
有关详细信息，请参阅 Yocto 项目移植说明中的 \href{https://docs.yoctoproject.org/migration-guides/migration-3.4.html#override-syntax-changes}{Overrides Syntax Changes} 部分。

\end{noteblock}

\newsubsection{Key Expansion}{关键词扩展}

Key expansion happens when the BitBake datastore is finalized. To better understand this, consider the following example:

当 BitBake 数据存储最终确定时，会发生关键词扩展。为了更好地理解这一点，请考虑以下示例：

\begin{pyglist}
A${B} = "X"
B = "2"
A2 = "Y"
\end{pyglist}

In this case, after all the parsing is complete, BitBake expands \code{${B}} into ``2''. This expansion causes \code{A2}, which was set to ``Y'' before the expansion, to become ``X''.

在本例中，当所有元数据都已经解析完成后，BitBake 会扩展 \code{${B}} 为 ``2''。此扩展导致变量 \code{A2} 在扩展之前设置为 ``Y'' 的值变更为 ``X''。

\newsubsection{Examples}{示例}

Despite the previous explanations that show the different forms of variable definitions, it can be hard to work out exactly what happens when variable operators, conditional overrides, and unconditional overrides are combined. This section presents some common scenarios along with explanations for variable interactions that typically confuse users.

尽管前面的章节解释变量定义的不同形式，但是读者很难准确地弄清楚当这些变量运算符、条件重写声明和无条件重写声明组合在一起时会发生什么。本节介绍一些常见使用场景以及对一些由这几种语法的相互作用所引起的用户困惑的解释。

There is often confusion concerning the order in which overrides and various ``append'' operators take effect. Recall that an append or prepend operation using ``:append'' and ``:prepend'' does not result in an immediate assignment as would ``+='', ``.='', ``=+'', or ``=.''. Consider the following example:

关于重写和各种``附加''运算符生效的顺序经常会出现混乱。回想一下，使用``:append''和``:prepend''的附加或前置操作不会像``+=''、``.=''、``=+'' 或 ``=.'' 那样导致变量立即被赋值。考虑以下示例：

\begin{pyglist}
OVERRIDES = "foo"
A = "Z"
A:foo:append = "X"
\end{pyglist}

For this case, A is unconditionally set to ``Z'' and ``X'' is unconditionally and immediately appended to the variable A:foo. Because overrides have not been applied yet, \code{A:foo} is set to ``X'' due to the append and \code{A} simply equals ``Z''.

对于这种情况，变量 \code{A} 在这里是无条件地被设置为 ``Z''，并且 ``X'' 也是无条件地被立即附加到变量 \code{A:foo} 上去。由于重写操作还尚未应用，变量 \code{A:foo} 因此由于 \code{:append} 操作符而被设置为 ``X''，而其变量 \code{A} 在此情况下也是简单地等于 ``Z''。

Applying overrides, however, changes things. Since ``foo'' is listed in \bbgls{OVERRIDES}, the conditional variable A is replaced with the ``foo'' version, which is equal to ``X''. So effectively, \code{A:foo} replaces \code{A}.

然而，应用重写操作符会改变事情的结果。由于变量 \bbgls{OVERRIDES} 的值的列表中列出了 ``foo'' ，因此条件变量 \code{A} 被替换为 ``foo''版本，它等于 ``X''。因此变量 \code{A:foo} 有效地取代了变量 \code{A}.

This next example changes the order of the override and the append:

下一个示例更改了重写操作和附加操作的顺序：

\begin{pyglist}
OVERRIDES = "foo"
A = "Z"
A:append:foo = "X"
\end{pyglist}

For this case, before overrides are handled, \code{A} is set to ``Z'' and \code{A:append:foo} is set to ``X''. Once the override for ``foo'' is applied, however, \code{A} gets appended with ``X''. Consequently, A becomes ``ZX''. Notice that spaces are not appended.

对于这种情况，在处理重写操作之前，变量 \code{A} 设置为 ``Z''，变量 \code{A:append:foo} 设置为``X''。然而，一旦应用了``foo''的重写操作，变量 \code{A} 就会被附加 ``X''。因此，变量A就会变为 ``ZX''。请注意，附加 ``X'' 时并未附加额外的空格。

This next example has the order of the appends and overrides reversed back as in the first example:
下一个示例的附加操作和重写操作顺序与第一个示例正好相反：

\begin{pyglist}
OVERRIDES = "foo"
A = "Y"
A:foo:append = "Z"
A:foo:append = "X"
\end{pyglist}

For this case, before any overrides are resolved, \code{A} is set to ``Y'' using an immediate assignment. After this immediate assignment, \code{A:foo} is set to ``Z'', and then further appended with ``X'' leaving the variable set to ``ZX''. Finally, applying the override for ``foo'' results in the conditional variable \code{A} becoming ``ZX'' (i.e. \code{A} is replaced with \code{A:foo}).

对于这种情况，在应用任何重写操作之前， 变量 \code{A} 使用立即分配方式将其值设置为 ``Y''。在立即赋值后，变量 \code{A:foo}设置为 ``Z''，然后进一步附加 ``X''，将变量的值设置为 ``ZX‘’。最后，对 ``foo'' 应用重写操作会导致条件变量 \code{A} 变为 ``ZX''（即变量 \code{A} 替换为变量 \code{A:foo}）。

This final example mixes in some varying operators:

最后一个示例混合了一些不同的运算符：

\begin{pyglist}
A = "1"
A:append = "2"
A:append = "3"
A += "4"
A .= "5"
\end{pyglist}

For this case, the type of append operators are affecting the order of assignments as BitBake passes through the code multiple times. Initially, \code{A} is set to ``1 45'' because of the three statements that use immediate operators. After these assignments are made, BitBake applies the ``:append'' operations. Those operations result in \code{A} becoming ``1 4523''.

对于这种情况，当 BitBake 多次来回解析这些代码时，附加运算符的类型会影响赋值的顺序。最初，变量 \code{A} 由于三个使用立即运算符的语句，其值被设置为``1 45''。在完成这些赋值任务后，BitBake 将开始应用 ``:append'' 运算符。这些附加运算符操作的结果是变量 \code{A} 变成了 ``1 4523''。

\newsection{Sharing Functionality}{共享功能}

BitBake allows for metadata sharing through include files (\code{.inc}) and class files (\code{.bbclass}). For example, suppose you have a piece of common functionality such as a task definition that you want to share between more than one recipe. In this case, creating a \code{.bbclass} file that contains the common functionality and then using the \code{inherit} directive in your recipes to inherit the class would be a common way to share the task.

BitBake 允许通过包含文件 (\code{.inc}) 和类文件 (\code{.bbclass}) 来共享元数据。例如假设你有一个通用功能（比如一个要在多个配方之间共享的任务定义）。在这种情况下，创建一个 \code{.bbclass} 类文件来包含这个任务的通用功能，然后在配方文件中使用 \code{inherit} 指令来继承该类以达到共享此任务的定义是一种常用的功能共享方法。

This section presents the mechanisms BitBake provides to allow you to share functionality between recipes. Specifically, the mechanisms include \code{include}, \code{inherit}, \bbgls{INHERIT}, and \code{require} directives.

本节将介绍 BitBake 提供的允许你在配方之间共享功能的一些机制。具体来说，这些机制包括 \code{include}、\code{inherit}、\bbgls{INHERIT} 和\code{require} 指令。

\newsubsection{Locating Include and Class Files}{定位包含文件和类文件}

BitBake uses the \bbgls{BBPATH} variable to locate needed include and class files. Additionally, BitBake searches the current directory for \code{include} and \code{require} directives.

BitBake 使用 \bbgls{BBPATH} 变量来定位所需的包含文件和类文件。此外，对于 \code{include} 和 \code{require} 指令，BitBake 还会搜索当前目录。

\begin{noteblock}{Note}%
The \bbgls{BBPATH} variable is analogous to the environment variable \code{PATH}.

\medskip
\bbgls{BBPATH} 变量类似于环境变量 \code{PATH}。
\end{noteblock}


In order for include and class files to be found by BitBake, they need to be located in a ``classes'' subdirectory that can be found in \bbgls{BBPATH}.

为了让 BitBake 能够找到所需的包含文件和类文件，这些文件需要保存在 \bbgls{BBPATH} 中的 ``classes'' 子目录中。

\newsubsection{\texttt{inherit} Directive}{\texttt{inherit} 指令}
\label{section:inherit}

When writing a recipe or class file, you can use the \code{inherit} directive to inherit the functionality of a class (\code{.bbclass}). BitBake only supports this directive when used within recipe and class files (i.e. \code{.bb} and \code{.bbclass}).

在编写配方或者类文件时，可以使用 \code{inherit} 指令来继承类的功能（\code{.bbclass}）。BitBake 仅支持在配方文件（\code{.bb}）和类文件（\code{.bbclass}）中使用 \code{inherit} 指令。

The \code{inherit} directive is a rudimentary means of specifying functionality contained in class files that your recipes require. For example, you can easily abstract out the tasks involved in building a package that uses Autoconf and Automake and put those tasks into a class file and then have your recipe inherit that class file.

\code{inherit} 指令是让配方获得所需要的包含在一些类文件中的功能的基本方法。例如，你可以轻松地抽象出构建出使用 Autoconf 和 A​​utomake 这两个软件包所涉及的任务，并将这些任务放入一个类文件中，然后再让配方文件通过 \code{inherit} 指令来继承该类文件从而获得这些任务的功能。

As an example, your recipes could use the following directive to inherit an \code{autotools.bbclass} file. The class file would contain common functionality for using Autotools that could be shared across recipes:

例如，你的配方文件可以使用以下指令来继承类文件 \code{autotools.bbclass}。该类文件包含了可以在配方之间共享的使用 \code{Autotools} 的一些通用功能：

\begin{pyglist}
inherit autotools
\end{pyglist}

In this case, BitBake would search for the directory \code{classes/autotools.bbclass} in \bbgls{BBPATH}.

在这种情况下，BitBake 会在 \bbgls{BBPATH} 定义的目录路径中来搜索 \code{classes/autotools.bbclass} 文件。

\begin{noteblock}{Note}%
You can override any values and functions of the inherited class within your recipe by doing so after the ``inherit'' statement.

\medskip
你可以在 ``inherit'' 语句之后重写配方中所继承的类的任何变量的值和所定义的函数。
\end{noteblock}

If you want to use the directive to inherit multiple classes, separate them with spaces. The following example shows how to inherit both the \code{buildhistory} and \code{rm_work} classes:

如果要使用指令来继承多个类，累的名称之间要用空格来进行分隔。以下示例显示了如何继承 \code{buildhistory} 和 \code{rm_work} 这两个类：

\begin{pyglist}
inherit buildhistory rm_work
\end{pyglist}

An advantage with the inherit directive as compared to both the \bbsection{include} and \bbsection{require} directives is that you can inherit class files conditionally. You can accomplish this by using a variable expression after the \code{inherit} statement. Here is an example:

与 \code{include} 和 \code{require} 这两个指令相比，\code{inherit} 指令的一个优点是你可以有条件地来继承类文件。你可以通过在 \code{inherit} 语句后使用变量表达式来完成此继承操作。参见下面的示例：

\begin{pyglist}
inherit ${VARNAME}
\end{pyglist}

If \code{VARNAME} is going to be set, it needs to be set before the \code{inherit} statement is parsed. One way to achieve a conditional inherit in this case is to use overrides:

如果变量 \code{VARNAME} 是需要进行赋值设置，则它的值需要在BitBake 对 \code{inherit} 语句进行解析之前就设置好。在这种情况下实现条件继承的一种方法是使用重写：

\begin{pyglist}
VARIABLE = ""
VARIABLE:someoverride = "myclass"
\end{pyglist}

Another method is by using anonymous Python. Here is an example:

另一种方法是使用匿名 Python 函数。参见下面的示例：
\begin{pyglist}
python () {
    if condition == value:
        d.setVar('VARIABLE', 'myclass')
    else:
        d.setVar('VARIABLE', '')
}
\end{pyglist}

Alternatively, you could use an in-line Python expression in the following form:

或者，你可以使用以下形式的内联 Python 代码表达式：

\begin{pyglist}
inherit ${@'classname' if condition else ''}
inherit ${@functionname(params)}
\end{pyglist}

In all cases, if the expression evaluates to an empty string, the statement does not trigger a syntax error because it becomes a no-op.

在所有情况下，即使表达式的计算结果为空字符串，该语句也不会触发语法错误，因为它实际上是一种空操作。

\newsubsection{\texttt{include} Directive}{\texttt{include} 指令}
\label{section:include}

BitBake understands the \code{include} directive. This directive causes BitBake to parse whatever file you specify, and to insert that file at that location. The directive is much like its equivalent in Make except that if the path specified on the include line is a relative path, BitBake locates the first file it can find within \bbgls{BBPATH}.

BitBake 也支持 \code{include} 指令。该指令能够让 BitBake 来解析你指定的任何文件，并将该文件插入到使用 \code{include} 指令的位置。该指令与 Make 中的指令非常相似，不同之处在于，如果在 \code{include} 中指定的路径是相对路径，则 BitBake 会使用在 \bbgls{BBPATH} 指定的搜索路径中找到的第一个文件。

The include directive is a more generic method of including functionality as compared to the \bbsection{inherit} directive, which is restricted to class (i.e. \code{.bbclass}) files. The include directive is applicable for any other kind of shared or encapsulated functionality or configuration that does not suit a \code{.bbclass} file.

与 \code{inherit} 指令相比，\code{include} 指令是一种更为通用的提供文件包含功能的方法，而 \code{inherit} 指令仅限于类（即.bbclass）文件。 \code{include} 指令适用于来包含那些不适合用 \code{.bbclass} 类文件，但是可以用任何其他类型文件来共享或封装的功能或配置。

As an example, suppose you needed a recipe to include some self-test definitions:

例如，假设你需要包含在配方文件中包含一些自我测试功能的定义：

\begin{pyglist}
include test_defs.inc
\end{pyglist}

\begin{noteblock}{Note}%
The include directive does not produce an error when the file cannot be found. Consequently, it is recommended that if the file you are including is expected to exist, you should use \bbsection{require} instead of \bbsection{include} . Doing so makes sure that an error is produced if the file cannot be found.

\medskip
BitBake 在处理 \code{include} 指令但是找不到所要包含的文件的情况下，并不会产生任务错误报告。因此建议如果需要要包含的文件必须是存在的，则应使用\code{require} 指令而不是 \code{include} 指令。这样做可确保在找不到所要包含的文件时 BitBake 会产生错误报告。
\end{noteblock}

\newsubsection{\texttt{require} Directive}{\texttt{require} 指令}
\label{section:require}

BitBake understands the \code{require} directive. This directive behaves just like the \code{include} directive with the exception that BitBake raises a parsing error if the file to be included cannot be found. Thus, any file you require is inserted into the file that is being parsed at the location of the directive.

BitBake 也支持 \code{require} 指令。该指令的行为与 \code{include} 指令类似，但是 \code{require} 指令如果找不到所要包含的文件，BitBake 会报告解析错误。因此，你所需要的任何文件都会插入到正在解析的的文件的 \code{require} 指令位置。

The require directive, like the include directive previously described, is a more generic method of including functionality as compared to the \bbsection{inherit} directive, which is restricted to class (i.e. \code{.bbclass}) files. The require directive is applicable for any other kind of shared or encapsulated functionality or configuration that does not suit a \code{.bbclass} file.

与前面描述的 \code{include} 指令一样，\code{require} 指令是一种更通用的提供文件包含功能的方法，而 \code{inherit} 指令则仅限于用来继承类（即 \code{.bbclass}）文件。\code{require} 指令也适用于来包含那些不适合用 \code{.bbclass} 类文件，但是可以用任何其他类型文件来共享或封装的功能或配置。

Similar to how BitBake handles \bbsection{include}, if the path specified on the require line is a relative path, BitBake locates the first file it can find within \bbgls{BBPATH}.

与 BitBake 处理 \code{include} 指令的方式类似，如果 \code{require} 指令上指定的路径是相对路径，BitBake 会使用它在 \bbgls{BBPATH} 所指定的搜索目录中找到的第一个文件。

As an example, suppose you have two versions of a recipe (e.g. \code{foo_1.2.2.bb} and \code{foo_2.0.0.bb}) where each version contains some identical functionality that could be shared. You could create an include file named \code{foo.inc} that contains the common definitions needed to build ``foo''. You need to be sure \code{foo.inc} is located in the same directory as your two recipe files as well. Once these conditions are set up, you can share the functionality using a require directive from within each recipe:

例如，假设你有两个版本的配方（例如 \code{foo_1.2.2.bb} 和 \code{foo_2.0.0.bb}），每个版本都包含一些可以共享的相同功能。在这种情况下，你可以创建一个名为 \code{foo.inc} 的包含文件，\code{foo.inc} 包含了构建 ``foo'' 所需的一些通用定义。同时你还需要确保此文件与这两个配方文件保存在相同的目录中。在设置这些条件后，你可以在每个配方文件中使用 \code{require} 指令来包含 \code{foo.inc} 所定义的那些共享功能：

\begin{pyglist}
require foo.inc
\end{pyglist}

\newsubsection{\texttt{INHERIT} Configuration Directive}{\texttt{INHERIT} 配置指令}
\label{section:INHERIT Configuration Directive}

When creating a configuration file (\code{.conf}), you can use the \bbgls{INHERIT} configuration directive to inherit a class. BitBake only supports this directive when used within a configuration file.

在创建配置文件（\code{.conf}）时，可以使用 \code{INHERIT} 配置指令来继承一个类。BitBake 仅在配置文件中中支持此 \code{INHERIT} 指令。

As an example, suppose you needed to inherit a class file called \code{abc.bbclass} from a configuration file as follows:

举例来说，假设你需要在配置文件中继承一个名为 \code{abc.bbclass} 的类文件，如下所示：

\begin{pyglist}
INHERIT += "abc"
\end{pyglist}

This configuration directive causes the named class to be inherited at the point of the directive during parsing. As with the \code{inherit} directive, the \code{.bbclass} file must be located in a ``classes'' subdirectory in one of the directories specified in \bbgls{BBPATH}.

此配置指令会让 BitBake 在解析此指令的地方来继承所指定的类。与 \code{inherit} 指令一样 ，该 \code{.bbclass} 类文件必须位于 \bbgls{BBPATH} 中所指定的目录之一的 ``classes'' 子目录中。

\begin{noteblock}{Note}%
Because .conf files are parsed first during BitBake's execution, using INHERIT to inherit a class effectively inherits the class globally (i.e. for all recipes).

\medskip
因为在 BitBake 执行期间它首先解析 \code{.conf} 配置文件，所以在配置文件中使用 \code{INHERIT} 中继承一个类实际上相当于全局继承该类（即所有配方都会继承它）。
\end{noteblock}

If you want to use the directive to inherit multiple classes, you can provide them on the same line in the \code{local.conf} file. Use spaces to separate the classes. The following example shows how to inherit both the \code{autotools} and \code{pkgconfig} classes:

如果要使用该指令来继承多个类，可以在 \code{local.conf} 文件中的同一行的地方把这些类的名字全部列出来，但是需要使用空格来分隔它们。以下示例展示了如何继承 \code{autotools} 类和 \code{pkgconfig} 类：

\begin{pyglist}
INHERIT += "autotools pkgconfig"
\end{pyglist}

\newsection{Functions}{函数}
\label{section:Functions}

As with most languages, functions are the building blocks that are used to build up operations into tasks. BitBake supports these types of functions:

与大多数编程语言一样，函数是用于将操作构建为任务的构建模块。 BitBake 支持以下类型的函数：

\begin{itemize}
\setlength\itemsep{1.0em}
\item \textbf{Shell Functions:} Functions written in shell script and executed either directly as functions, tasks, or both. They can also be called by other shell functions.

\medskip
\textbf{Shell 函数:} 用 Shell 脚本编写的函数，可直接作为函数、任务或两者来直接执行。它们也可以被其他 Shell 函数调用。

\item \textbf{BitBake-Style Python Functions:} Functions written in Python and executed by BitBake or other Python functions using \code{bb.build.exec_func()}.

\medskip
\textbf{BitBake 风格的 Python 函数:} 用 Python 编写并由 BitBake 或其他 Python 函数使用 \code{bb.build.exec_func()} 来执行的函数.

\item \textbf{Python Functions:} Functions written in Python and executed by Python.

\medskip
\textbf{Python 函数:} 用 Python 编写并由 Python 执行的函数

\item \textbf{Anonymous Python Functions:} Python functions executed automatically during parsing.

\medskip
\textbf{匿名 Python 函数:} 解析期间自动执行的 Python 函数。
\end{itemize}

Regardless of the type of function, you can only define them in class (\code{.bbclass}) and recipe (\code{.bb} or \code{.inc}) files.


无论何种类型的函数，你只能在类文件（\code{.bbclass}）和 配方文件（\code{.bb} 或 \code{.inc}）中定义它们。


\newsubsection{Shell Functions}{Shell 函数}
\label{section:Shell Functions}

Functions written in shell script are executed either directly as functions, tasks, or both. They can also be called by other shell functions. Here is an example shell function definition:

在 shell 脚本中编写的函数可以直接作为函数、任务或两者执行。它们也可以被其他 shell 函数调用。以下是 shell 函数定义示例：

\begin{pyglist}
some_function () {
    echo "Hello World"
}
\end{pyglist}

When you create these types of functions in your recipe or class files, you need to follow the shell programming rules. The scripts are executed by \code{/bin/sh}, which may not be a bash shell but might be something such as dash. You should not use Bash-specific script (bashisms).

在配方文件或类文件中创建这些类型的函数时，你需要遵循 shell 编程规则。脚本由 \code{/bin/sh} 来执行，它可能不是 bash shell，但可能是 dash 之类的东西。你不能使用只能用于 Bash shell 的脚本（bashisms）\footnotemark[1]。

\footnotetext[1]{sh (Bourne Shell) 与 Bash (Bourne Again Shell) 是两种不同的 Shell，两者的语法是不一样的。}

Overrides and override-style operators like \code{:append} and \code{:prepend} can also be applied to shell functions. Most commonly, this application would be used in a \code{.bbappend} file to modify functions in the main recipe. It can also be used to modify functions inherited from classes.

重写和重写式运算符（如 \code{:append}和 \code{:prepend}） 也可应用于 shell 函数。最常见的是，此应用程序将在文件 \code{.bbappend} 中用于修改主配方中的函数。它还可用于修改从类继承的函数。

As an example, consider the following:

示例如下：

\begin{pyglist}
do_foo() {
    bbplain first
    fn
}

fn:prepend() {
    bbplain second
}

fn() {
    bbplain third
}

do_foo:append() {
    bbplain fourth
}
\end{pyglist}

Running \code{do_foo} prints the following:

运行\code{do_foo} 任务则会打印出下面的结果：

\begin{pyglist}
recipename do_foo: first
recipename do_foo: second
recipename do_foo: third
recipename do_foo: fourth
\end{pyglist}

\begin{noteblock}{Note}%
Overrides and override-style operators can be applied to any shell function, not just \bbsection{tasks}.

\medskip
重写和重写式运算符可应用于任何 shell 函数，而不仅仅是任务函数。
\end{noteblock}

You can use the \code{bitbake -e recipename} command to view the final assembled function after all overrides have been applied.

你可以使用 \code{bitbake -e recipename} 该命令来查看在应用所有重写操作后的最终完成的函数的定义。

\newsubsection{BitBake-Style Python Functions}{BitBake 风格的 Python 函数}
\label{section:BitBake-Style Python Functions}
These functions are written in Python and executed by BitBake or other Python functions using \code{bb.build.exec_func()}.

这些函数是用 Python 编写的，并由 BitBake 或其他 Python 函数通过调用 \code{bb.build.exec_func()} 来执行。

An example BitBake function is:

BitBake 函数的一个示例是：

\begin{pyglist}
python some_python_function () {
    d.setVar("TEXT", "Hello World")
    print d.getVar("TEXT")
}
\end{pyglist}

Because the Python ``bb'' and ``os'' modules are already imported, you do not need to import these modules. Also in these types of functions, the datastore (``d'') is a global variable and is always automatically available.

由于 Python 的 ``bb'' 和 ``os'' 模块已导入，因此你无需再导入这些模块。此外，在这些类型的函数中，数据存储区（``d''）是一个全局变量，并且是始终可用的。

\begin{noteblock}{Note}%
Variable expressions (e.g. \code{${X}} ) are no longer expanded within Python functions. This behavior is intentional in order to allow you to freely set variable values to expandable expressions without having them expanded prematurely. If you do wish to expand a variable within a Python function, use \code{d.getVar("X")} . Or, for more complicated expressions, use \code{d.expand()}.

\medskip
变量表达式（例如 \code{${X}}）不再在 Python 函数中展开。此行为是故意为之的，其目的是让你可以自由地将变量值设置为可扩展表达式，而不会过早展开它们。如果你确实希望在 Python 函数中展开变量，请使用表达式 \code{d.getVar("X")}。或者，对于更复杂的表达式，请使用 \code{d.expand()}。
\end{noteblock}

Similar to shell functions, you can also apply overrides and override-style operators to BitBake-style Python functions.

与 shell 函数类似，你也可以将重写和重写式运算符应用于 BitBake 样式的 Python 函数。

As an example, consider the following:

例如，请考虑以下示例：

\begin{pyglist}
python do_foo:prepend() {
    bb.plain("first")
}

python do_foo() {
    bb.plain("second")
}

python do_foo:append() {
    bb.plain("third")
}
\end{pyglist}

Running \code{do_foo} prints the following:

运行 \code{do_foo} 则会打印出以下内容：

\begin{pyglist}
recipename do_foo: first
recipename do_foo: second
recipename do_foo: third
\end{pyglist}

You can use the \code{bitbake -e recipename} command to view the final assembled function after all overrides have been applied.

你可以使用 \code{bitbake -e recipename} 该命令来查看在应用所有重写操作后的最终完成的函数的定义。

\newsubsection{Python Functions}{Python 函数}

These functions are written in Python and are executed by other Python code. Examples of Python functions are utility functions that you intend to call from in-line Python or from within other Python functions. Here is an example:

这些函数是用 Python 编写的，并由其他 Python 代码执行。Python 函数的示例包括你希望从其他内联 Python 函数或其他普通 Python 函数中调用的实用函数。以下是示例：

\begin{pyglist}
def get_depends(d):
    if d.getVar('SOMECONDITION'):
        return "dependencywithcond"
    else:
        return "dependency"

SOMECONDITION = "1"
DEPENDS = "${@get_depends(d)}"
\end{pyglist}

This would result in \bbgls{DEPENDS} containing \code{dependencywithcond}.

这将导致 \bbgls{DEPENDS} 变量的值变为 \code{dependencywithcond}。

Here are some things to know about Python functions:

以下是有关 Python 函数的一些知识：

\begin{itemize}
\setlength\itemsep{1.0em}
\item Python functions can take parameters.

\medskip
Python 函数可以接受参数。

\item The BitBake datastore is not automatically available. Consequently, you must pass it in as a parameter to the function.

\medskip
BitBake 数据存储区不会自动变成可用数据。因此，你必须将其作为参数传递给函数。

\item The ``bb'' and ``os'' Python modules are automatically available. You do not need to import them.

\medskip
``bb'' 和 ``os'' 这两个 Python 模块自动被导入，你可以无需再导入它们而直接使用。

\end{itemize}

\newsubsection{BitBake-Style Python Functions Versus Python Functions}{BitBake 样式的 Python 函数与 Python 函数}

Following are some important differences between BitBake-style Python functions and regular Python functions defined with ``def'':

以下是 BitBake 风格的 Python 函数与使用 ``def'' 定义的常规 Python 函数之间的一些重要区别：

\begin{itemize}
\setlength\itemsep{1.0em}
\item Only BitBake-style Python functions can be \bbsections{Tasks}{tasks}.

\medskip
只有 BitBake 风格的 Python 函数才可以是\bbsections{Tasks}{任务}函数。

\item Overrides and override-style operators can only be applied to BitBake-style Python functions.

\medskip
重写和重写式运算符只能应用于 BitBake 样式的 Python 函数。

\item Only regular Python functions can take arguments and return values.

\medskip
只有常规的 Python 函数可以接受参数并返回值。

\item \bbsection{Variable flags} such as \code{[dirs]}, \code{[cleandirs]}, and \code{[lockfiles]} can be used on BitBake-style Python functions, but not on regular Python functions.

\medskip
\bbsections{Variable flags}{变量标志}（例如 \code{[dirs]}、\code{[cleandirs]}和 \code{[lockfiles]}）可以在 BitBake 风格的 Python 函数中使用，但不能在常规 Python 函数中使用。

\item BitBake-style Python functions generate a separate \code{${T}/run.function-name.pid} script that is executed to run the function, and also generate a log file in \code{${T}/log.function-name.pid} if they are executed as tasks.

\medskip
BitBake 风格的 Python 函数会生成一个单独的 \code{${T}/run.function-name.pid} 脚本，该脚本会被用来执行以运行该函数，并且如果这些函数是作为任务函数来执行的，还会生成一个名为 \code{${T}/log.function-name.pid} 的日志文件。

Regular Python functions execute ``inline'' and do not generate any files in \code{${T}}.

常规 Python 函数是以 ``内联''函数的形式来执行的，并且不会在 \code{${T}} 目录中生成任何文件。

\item Regular Python functions are called with the usual Python syntax. BitBake-style Python functions are usually tasks and are called directly by BitBake, but can also be called manually from Python code by using the \code{bb.build.exec_func()} function. Here is an example:

\medskip
常规 Python 函数使用通常的 Python 语法调用。BitBake 样式的 Python 函数通常是任务，由 BitBake 直接调用，但也可以使用 \code{bb.build.exec_func()} 函数来手动调用这些函数。以下是示例：

\begin{pyglist}
bb.build.exec_func("my_bitbake_style_function", d)
\end{pyglist}

\begin{noteblock}{Note}%
\code{bb.build.exec_func()} can also be used to run shell functions from Python code. If you want to run a shell function before a Python function within the same task, then you can use a parent helper Python function that starts by running the shell function with \code{bb.build.exec_func()} and then runs the Python code.

\medskip
\code{bb.build.exec_func()} 也可用于在 Python 代码中运行 shell 函数。如果你想在同一任务中先运行 shell 函数，然后再运行 Python 函数，则可以使用同一任务中的上一级的 Python 函数，该函数首先使用 \code{bb.build.exec_func()} 来调用 shell 函数，然后再运行 ​​Python 代码。
\end{noteblock}

\medskip
To detect errors from functions executed with \code{bb.build.exec_func()}, you can catch the \code{bb.build.FuncFailed} exception.

\medskip
要发现通过 \code{bb.build.exec_func()} 来执行的函数所引发的错误 ，可以通过捕获 \code{bb.build.FuncFailed} 异常来实现。

\begin{noteblock}{Note}%
Functions in metadata (recipes and classes) should not themselves raise \code{bb.build.FuncFailed}. Rather, \code{bb.build.FuncFailed} should be viewed as a general indicator that the called function failed by raising an exception. For example, an exception raised by \code{bb.fatal()} will be caught inside \code{bb.build.exec_func()}, and a \code{bb.build.FuncFailed} will be raised in response.

\medskip
元数据（配方和类）中的函数本身不应引发 \code{bb.build.FuncFailed}。相反，应将 \code{bb.build.FuncFailed} 其视为被调用函数因引发异常而失败的一般指示。例如，由 \code{bb.fatal()} 引发的异常将在 \code{bb.build.exec_func()} 内被捕获，并且\code{bb.build.FuncFailed} 将作为响应而被引发。
\end{noteblock}
\end{itemize}

Due to their simplicity, you should prefer regular Python functions over BitBake-style Python functions unless you need a feature specific to BitBake-style Python functions. Regular Python functions in metadata are a more recent invention than BitBake-style Python functions, and older code tends to use \code{bb.build.exec_func()} more often.

由于常规 Python 函数的简单性，除非你需要一些只有 BitBake 样式 Python 函数才能提供的功能，否则你应该优先使用常规 Python 函数而不是 BitBake 样式 Python 函数。元数据中的常规 Python 函数比 BitBake 样式 Python 函数更新颖，并且旧代码往往使用 \code{bb.build.exec_func()} 得更频繁。

\subsection{Anonymous Python Functions}{匿名 Python 函数}
\label{section:Anonymous Python Functions}
Sometimes it is useful to set variables or perform other operations programmatically during parsing. To do this, you can define special Python functions, called anonymous Python functions, that run at the end of parsing. For example, the following conditionally sets a variable based on the value of another variable:

有时在解析过程中以编程方式设置变量或执行其他操作是非常有用的。为此，你可以定义特殊的 Python 函数（称为匿名 Python 函数）以在解析结束时运行。例如，以下代码根据另一个变量的值有条件地设置一个变量：

\begin{pyglist}
python () {
    if d.getVar('SOMEVAR') == 'value':
        d.setVar('ANOTHERVAR', 'value2')
}
\end{pyglist}

An equivalent way to mark a function as an anonymous function is to give it the name ``\_\_anonymous'', rather than no name.

将函数标记为匿名函数的等效方法是赋予其名称 ``\_\_anonymous''，而不是不命名。

Anonymous Python functions always run at the end of parsing, regardless of where they are defined. If a recipe contains many anonymous functions, they run in the same order as they are defined within the recipe. As an example, consider the following snippet:

匿名 Python 函数,无论它们在何处定义, 始终是在解析结束时开始运行。如果配方中包含了许多匿名函数，则它们将按照配方中定义的顺序来运行。例如，参见以下代码片段：

\begin{pyglist}
python () {
    d.setVar('FOO', 'foo 2')
}

FOO = "foo 1"

python () {
    d.appendVar('BAR',' bar 2')
}

BAR = "bar 1"
\end{pyglist}

The previous example is conceptually equivalent to the following snippet:

前面的示例在概念上等同于以下代码片段：

\begin{pyglist}
FOO = "foo 1"
BAR = "bar 1"
FOO = "foo 2"
BAR += "bar 2"
\end{pyglist}

FOO ends up with the value ``foo 2'', and BAR with the value ``bar 1 bar 2''. Just as in the second snippet, the values set for the variables within the anonymous functions become available to tasks, which always run after parsing.

变量 \code{FOO} 最终的值为``foo 2''， 变量 \code{BAR} 最终的值为 ``bar 1 bar 2''。与第二个代码片段一样，这些函数也是在解析后才运行，匿名函数中变量的值在函数运行后可供任务使用。

Overrides and override-style operators such as ``\code{:append}'' are applied before anonymous functions run. In the following example, \code{FOO} ends up with the value ``foo from anonymous'':

重写和重新式运算符（例如 \code{:append}）是在匿名函数运行之前应用的。在以下示例中，变量 \code{FOO} 的最终值为“foo from anonymous”：

\begin{pyglist}
FOO = "foo"
FOO:append = " from outside"

python () {
    d.setVar("FOO", "foo from anonymous")
}
\end{pyglist}

For methods you can use with anonymous Python functions, see the ``\bbsection{Functions You Can Call From Within Python}'' section. For a different method to run Python code during parsing, see the ``\bbsection{Inline Python Variable Expansion}'' section.

有关使用匿名 Python 函数的方法，请参阅 ``\bbsections{Functions You Can Call From Within Python}{可在 Python 内部调用的函数}'' 部分。有关在解析期间运行 Python 代码的其他方法，请参阅 ``\bbsections{Inline Python Variable Expansion}{内联 Python 变量扩展}'' 部分。

\newsubsection{Flexible Inheritance for Class Functions}{类函数的灵活继承}

Through coding techniques and the use of \code{EXPORT_FUNCTIONS}, BitBake supports exporting a function from a class such that the class function appears as the default implementation of the function, but can still be called if a recipe inheriting the class needs to define its own version of the function.

通过编程技巧和使用 \code{EXPORT_FUNCTIONS} 变量，BitBake 可以支持从类中导出函数，使得此类函数可以作为某些函数的默认实现，即使继承该类的配方需要定义自己的函数，仍然可以调用此类函数。

To understand the benefits of this feature, consider the basic scenario where a class defines a task function and your recipe inherits the class. In this basic scenario, your recipe inherits the task function as defined in the class. If desired, your recipe can add to the start and end of the function by using the ``:prepend'' or ``:append'' operations respectively, or it can redefine the function completely. However, if it redefines the function, there is no means for it to call the class version of the function. \code{EXPORT_FUNCTIONS} provides a mechanism that enables the recipe's version of the function to call the original version of the function.

要了解此功能的好处，请考虑一个基本使用场景，即一个类定义了一个任务函数，而你的配方继承了该类。在此基本场景中，你的配方继承了此类中所定义的这个任务函数。如果需要，你的配方可以分别使用 ``\code{:prepend}'' 或 ``\code{:append}'' 操作添加到函数的开头和结尾，也可以完全重新定义该函数。但是，如果配方重新定义了该函数，则无法调用由此类所定义的版本。\code{EXPORT_FUNCTIONS} 则提供一种机制，使得配方版本的函数能够调用该函数定义在类中的原始版本。

To make use of this technique, you need the following things in place:

要使用此技术，你需要做好以下准备：

\begin{itemize}
\setlength\itemsep{1.0em}
\item The class needs to define the function as follows:

\medskip
该类按照如下格式来定义函数：

\medskip
\begin{pyglist}
classname_functionname
\end{pyglist}

\medskip
For example, if you have a class file bar.bbclass and a function named \code{do_foo}, the class must define the function as follows:

\medskip
例如，如果你有一个类文件名为 \code{bar.bbclass} 和一个名为 \code{do_foo} 的函数，则该类必须按如下方式定义该函数：

\medskip
\begin{pyglist}
bar_do_foo
\end{pyglist}

\item The class needs to contain the \code{EXPORT_FUNCTIONS} statement as follows:

\medskip
该类需要按照下面的语法来使用 \code{EXPORT_FUNCTIONS}：

\medskip
\begin{pyglist}
EXPORT_FUNCTIONS functionname
\end{pyglist}

\medskip
For example, continuing with the same example, the statement in the \code{bar.bbclass} would be as follows:

\medskip
例如，继续使用上面的同一个例子，\code{bar.bbclass} 将使用如下声明：

\medskip
\begin{pyglist}
EXPORT_FUNCTIONS do_foo
\end{pyglist}

\item You need to call the function appropriately from within your recipe. Continuing with the same example, if your recipe needs to call the class version of the function, it should call \code{bar_do_foo}. Assuming \code{do_foo} was a shell function and \code{EXPORT_FUNCTIONS} was used as above, the recipe's function could conditionally call the class version of the function as follows:

\item 你需要在配方中正确地调用该函数。继续使用上面相同的示例，如果你的配方需要调用该函数的类版本，则应调用\code{bar_do_foo}。假设 \code{do_foo} 是一个 shell 函数，并且 \code{EXPORT_FUNCTIONS} 的设定如上所述，则配方的函数可以有条件地调用该函数的类版本，如下所示：

\begin{pyglist}
do_foo() {
    if [ somecondition ] ; then
        bar_do_foo
    else
        # Do something else
    fi
}
\end{pyglist}

\medskip
To call your modified version of the function as defined in your recipe, call it as \code{do_foo}.

\medskip
要调用配方中自己定义的修改版本的函数，则直接调用 \code{do_foo} 即可。
\end{itemize}

With these conditions met, your single recipe can freely choose between the original function as defined in the class file and the modified function in your recipe. If you do not set up these conditions, you are limited to using one function or the other.

在满足这些条件后，你的配方文件就可以在类文件中定义的原始函数和配方中修改后的函数之间自由的选择了。如果你不设置这些条件，则只能使用其中的一个函数。

\newsection{Tasks}{任务}
\label{section:Tasks}

Tasks are BitBake execution units that make up the steps that BitBake can run for a given recipe. Tasks are only supported in recipes and classes (i.e. in .bb files and files included or inherited from \code{.bb} files). By convention, tasks have names that start with ``do\_''.

任务是 BitBake 的执行单元，也是BitBake 用来运行给定配方的步骤组成。只有配方文件和类文件（即在 \code{.bb} 文件和从 \code{.bb} 文件中包含或者继承的文件中）支持任务的定义。按照惯例，任务的名称以 ``do\_'' 开头。

\newsubsection{Promoting a Function to a Task}{将函数提升为任务}

Tasks are either \bbsections{Shell Functions}{shell functions} or \bbsections{BitBake-Style Python Functions}{BitBake-style Python functions} that have been promoted to tasks by using the \code{addtask} command. The \code{addtask} command can also optionally describe dependencies between the task and other tasks. Here is an example that shows how to define a task and declare some dependencies:

任务要么是 \bbsections{Shell Functions}{shell 函数}，要么是通过使用 \code{addtask} 命令提升为任务的\bbsections{BitBake-Style Python Functions}{BitBake 风格的 Python 函数}。\code{addtask} 命令还可以用来描述一个任务与其他任务之间的依赖关系。以下示例展示了如何来定义一个任务并声明一些依赖关系：

\begin{pyglist}
python do_printdate () {
    import time
    print time.strftime('\%Y\%m\%d', time.gmtime())
}

addtask printdate after do_fetch before do_build
\end{pyglist}

The first argument to \code{addtask} is the name of the function to promote to a task. If the name does not start with ``do\_'', ``do\_'' is implicitly added, which enforces the convention that all task names start with ``do\_''.


\code{addtask} 的第一个参数是要提升为任务的函数的名称。如果函数的名称不以 ``do\_'' 开头，BitBake会默认对函数名添加 ``do\_''，这会强制让其符合所有任务的名称都是以 ``do\_'' 开头的约定。

In the previous example, the \code{do_printdate} task becomes a dependency of the \code{do_build} task, which is the default task (i.e. the task run by the \code{bitbake} command unless another task is specified explicitly). Additionally, the \code{do_printdate} task becomes dependent upon the \code{do_fetch} task. Running the \code{do_build} task results in the \code{do_printdate} task running first.

在上面的例子中，\code{do_printdate} 任务成为 \code{do_build} 任务的依赖项，该任务是 BitBake 的默认任务（即除非在 \code{bitbake} 命令的输入参数中明确指定另一个任务，否则该任务将由 \code{bitbake} 命令直接运行）。此外，该\code{do_printdate} 任务依赖于 \code{do_fetch} 任务。运行 \code{do_build} 任务会导致 \code{do_printdate} 任务会首先运行。

\begin{noteblock}{Note}%

If you try out the previous example, you might see that the \code{do_printdate} task is only run the first time you build the recipe with the \code{bitbake} command. This is because BitBake considers the task ``up-to-date'' after that initial run. If you want to force the task to always be rerun for experimentation purposes, you can make BitBake always consider the task ``out-of-date'' by using the [\bbsections{Variable Flags}{nostamp}] variable flag, as follows:

\medskip
如果你试着来运行前面的示例，你可能会看到该 \code{do_printdate} 任务仅在第一次使用 \code{bitbake} 命令来构建配方时运行。 这是因为 BitBake 在首次运行后认为该任务是 ``最新的'' 而不需要重新运行。 如果你想强制 BitBake 在每次构建的时间都重新运行该任务以进行一些实验，你可以使用 \code{[nostamp]} 变量标志让 BitBake 始终认为该任务已经是``过时''了从而重新运行它，如下所示：

\medskip
\begin{pyglist}
do_printdate[nostamp] = "1"
\end{pyglist}

\medskip
You can also explicitly run the task and provide the -f option as follows:

\medskip
你还可以给 BitBake 提供 -f 选项来强制运行该任务，如下所示：

\medskip
\begin{pyglist}
$ bitbake recipe -c printdate -f
\end{pyglist}

\medskip
When manually selecting a task to run with the \code{bitbake recipe -c task} command, you can omit the ``do\_'' prefix as part of the task name.

\medskip
当使用 \code{bitbake recipe -c task} 命令来运行手动选择的任务时，可以省略任务名称中的 ``do\_'' 前缀。
\end{noteblock}

You might wonder about the practical effects of using addtask without specifying any dependencies as is done in the following example:

你可能也想知道在使用 \code{addtask} 命令但是不指定任何依赖项的实际效果， 如以下示例所示：

\begin{pyglist}
addtask printdate
\end{pyglist}

In this example, assuming dependencies have not been added through some other means, the only way to run the task is by explicitly selecting it with \code{bitbake recipe -c printdate}. You can use the \code{do_listtasks} task to list all tasks defined in a recipe as shown in the following example:

在此示例中，假设依赖项尚未通过其他方式进行添加，则运行此任务的唯一方法是使用 \code{bitbake -c printdate} 命令来明确的选择它。你还可以使用 \code{do_listtasks} 任务列出配方中定义的所有任务，如以下示例所示：

\begin{pyglist}
$ bitbake recipe -c listtasks
\end{pyglist}

For more information on task dependencies, see the ``\bbsection{Dependencies}'' section.

有关任务依赖关系的更多信息，请参阅 ``\bbsections{Dependencies}{依赖关系}'' 部分。

See the ``\bbsection{Variable Flags}'' section for information on variable flags you can use with tasks.

有关可在任务中使用的变量标志的信息，请参阅 ``\bbsections{Variable Flags}{变量标志}'' 部分。


\begin{noteblock}{Note}%
While it's infrequent, it's possible to define multiple tasks as dependencies when calling addtask. For example, here's a snippet from the OpenEmbedded class file \code{package_tar.bbclass}:

\medskip
一种不常见的使用场景是在调用 \code{addtask} 时将多个任务定义为依赖项。例如，以下是来自 OpenEmbedded 类文件 \code{package_tar.bbclass} 的代码片段：

\medskip
\begin{pyglist}
addtask package_write_tar before do_build after do_packagedata do_package
\end{pyglist}

\medskip
Note how the \code{package_write_tar} task has to wait until both of \code{do_packagedata} and \code{do_package} complete.

\medskip
请注意，\code{package_write_tar} 任务必须等到 \code{do_packagedata} 任务和 \code{do_package} 任务都完成了才会被运行。
\end{noteblock}

\newsubsection{Deleting a Task}{删除任务}

As well as being able to add tasks, you can delete them. Simply use the \code{deltask} command to delete a task. For example, to delete the example task used in the previous sections, you would use:

除了可以添加任务外，你还可以删除任务。只需使用 \code{deltask} 命令即可删除任务。例如，要删除前面部分中使用的示例任务，你可以使用：

\begin{pyglist}
deltask printdate
\end{pyglist}

If you delete a task using the \code{deltask} command and the task has dependencies, the dependencies are not reconnected. For example, suppose you have three tasks named \code{do_a}, \code{do_b}, and \code{do_c}. Furthermore, \code{do_c} is dependent on \code{do_b}, which in turn is dependent on \code{do_a}. Given this scenario, if you use \code{deltask} to delete \code{do_b}, the implicit dependency relationship between \code{do_c} and \code{do_a} through \code{do_b} no longer exists, and \code{do_c} dependencies are not updated to include \code{do_a}. Thus, \code{do_c} is free to run before \code{do_a}.

如果你使用 \code{deltask} 命令来删除任务，并且该任务具有一些依赖关系，在此任务被删除后，其他依赖关系不会重新更新。例如有三个名为 \code{do_a}、\code{do_b} 和 \code{do_c} 的任务。此外 \code{do_c} 依赖于 \code{do_b}，而 \code{do_b} 又依赖于 \code{do_a}。在这种情况下，如果你使用 \code{deltask} 将 \code{do_b} 删除，则 \code{do_a} 和\code{do_c} 之间的隐式依赖关系将不复存在， \code{do_c} 的依赖关系不会更新为包括 \code{do_a}。因此，\code{do_c}可以自由的在 \code{do_a} 之前运行，而不必等待 \code{do_a} 先运行。

If you want dependencies such as these to remain intact, use the \code{[noexec]} varflag to disable the task instead of using the \code{deltask} command to delete it:

如果你希望这些依赖关系保持完整，请使用变量标志 \code{[noexec]} 来禁用该任务，而不是使用 \code{deltask} 命令来删除它：

\begin{pyglist}
do_b[noexec] = "1"
\end{pyglist}

\newsubsection{Passing Information Into the Build Task Environment}{将信息传递到构建任务环境}
\label{section:Passing Information Into the Build Task Environment}

When running a task, BitBake tightly controls the shell execution environment of the build tasks to make sure unwanted contamination from the build machine cannot influence the build.

在运行任务时，BitBake 严格控制构建任务的 shell 执行环境，以确保构建主机的一些不必要变量不会污染 shell 环境，从而避免这些污染影响构建过程。

\begin{noteblock}{Note}%
By default, BitBake cleans the environment to include only those things exported or listed in its passthrough list to ensure that the build environment is reproducible and consistent. You can prevent this ``cleaning'' by setting the \bbgls{BB_PRESERVE_ENV} variable.

\medskip
在默认情况下，BitBake 会清理环境以使其仅包含那些导出的环境变量或者是在其直通列表中列出的内容，以确保构建环境可重现且保持一致。你可以通过设置 \bbgls{BB_PRESERVE_ENV} 变量来阻止这种 ``清理''。
\end{noteblock}

Consequently, if you do want something to get passed into the build task environment, you must take these two steps:
因此，如果你确实希望将某些内容传递到构建任务环境中去，则必须采取以下两个步骤：

\begin{enumerate}
\setlength\itemsep{1.0em}
\item Tell BitBake to load what you want from the environment into the datastore. You can do so through the\linebreak \bbgls{BB_ENV_PASSTHROUGH} and \bbgls{BB_ENV_PASSTHROUGH_ADDITIONS} variables. For example, assume you want to prevent the build system from accessing your \code{$HOME/.ccache} directory. The following command adds the the environment variable \code{CCACHE_DIR} to BitBake's passthrough list to allow that variable into the datastore:

\medskip
将你想要加载到数据存储区中的环境内容告诉 BitBake 。你可以通过 \bbgls{BB_ENV_PASSTHROUGH} 和\linebreak \bbgls{BB_ENV_PASSTHROUGH_ADDITIONS} 变量来执行此操作。例如，假设你想阻止构建系统访问你的 \code{$HOME/.ccache} 目录。以下命令将环境变量 \code{CCACHE_DIR} 添加到 BitBake 的直通列表中，以允许该变量进入数据存储区：

\begin{pyglist}
export BB_ENV_PASSTHROUGH_ADDITIONS="$BB_ENV_PASSTHROUGH_ADDITIONS CCACHE_DIR"
\end{pyglist}

\item Tell BitBake to export what you have loaded into the datastore to the task environment of every running task. Loading something from the environment into the datastore (previous step) only makes it available in the datastore. To export it to the task environment of every running task, use a command similar to the following in your local configuration file \code{local.conf} or your distribution configuration file:

\medskip
告诉 BitBake 将那些你已加载到数据存储中的内容导出到每个正在运行的任务的任务环境中去。将环境中的某些内容加载到数据存储中（上一步）只会使其在数据存储中可用。要将其导出到每个正在运行的任务的任务环境中，请在本地配置文件 \code{local.conf} 或发行版本的配置文件中使用类似于下面的命令：

\begin{pyglist}
export CCACHE_DIR
\end{pyglist}

\medskip
\begin{noteblock}{Note}%
A side effect of the previous steps is that BitBake records the variable as a dependency of the build process in things like the setscene checksums. If doing so results in unnecessary rebuilds of tasks, you can also flag the variable so that the setscene code ignores the dependency when it creates checksums.

\medskip
上述步骤的一个副作用是，BitBake 会将这些变量记录为构建过程中某些项目，比如场景设置（setscene）的校验和的依赖项。如果这样做的结果会导致某些不必要的任务被重复构建，你可以对这些变量进行标记以便场景设置（setscene）代码在创建校验和时来忽略这些依赖项。
\end{noteblock}
\end{enumerate}

Sometimes, it is useful to be able to obtain information from the original execution environment. BitBake saves a copy of the original environment into a special variable named \bbgls{BB_ORIGENV}.

能够从原始执行环境中获取信息有时是很有用的。BitBake 将原始环境的副本保存到名为 \bbgls{BB_ORIGENV} 这个特殊变量中。

The \bbgls{BB_ORIGENV} variable returns a datastore object that can be queried using the standard datastore operators such as \code{getVar(, False)}. The datastore object is useful, for example, to find the original \code{DISPLAY} variable. Here is an example:

\bbgls{BB_ORIGENV} 变量会返回一个可以使用标准数据存储区运算符（例如 \code{getVar(, False)}）进行查询的数据存储区对象。此数据存储区对象很有用，例如，可以用来查找变量 \code{DISPLAY} 的原始值。以下是示例：

\begin{pyglist}
origenv = d.getVar("BB_ORIGENV", False)
bar = origenv.getVar("BAR", False)
\end{pyglist}

The previous example returns \code{BAR} from the original execution environment.

上面的示例返回变量 \code{BAR} 在原始执行环境中的值。

\newsection{Variable Flags}{变量标志}
\label{section:Variable Flags}

Variable flags (varflags) help control a task's functionality and dependencies. BitBake reads and writes varflags to the datastore using the following command forms:

变量标志 (varflags) 有助于控制一个任务的功能和依赖关系。BitBake 使用以下命令形式来读取和写入变量标志（varflags） 到数据存储区中：

\begin{pyglist}
variable = d.getVarFlags("variable")
self.d.setVarFlags("FOO", {"func": True})
\end{pyglist}

When working with varflags, the same syntax, with the exception of overrides, applies. In other words, you can set, append, and prepend varflags just like variables. See the ``\bbsection{Variable Flag Syntax}'' section for details.

使用变量标志（varflags）时，除了重写操作之外，其与变量使用相同的语法。换句话说，你可以像变量一样来设置、附加和添加变量标志（varflags）。有关详细信息，请参阅 ``\bbsections{Variable Flag Syntax}{变量标志语法}'' 部分。

BitBake has a defined set of varflags available for recipes and classes. Tasks support a number of these flags which control various functionality of the task:

BitBake 为配方和类定义了一组不同的变量标志（varflags）。任务函数支持许多这种用来控制任务的各种功能的标志：

\begin{itemize}
\setlength\itemsep{1.0em}
\item \texttt{[cleandirs]}: Empty directories that should be created before the task runs. Directories that already exist are removed and recreated to empty them.

\medskip
\texttt{[cleandirs]}: 任务运行前应创建的空目录。已存在的目录将被删除并重新创建以清空它们。

\item \texttt{[depends]}: Controls inter-task dependencies. See the \bbgls{DEPENDS} variable and the ``\bbsection{Inter-Task Dependencies}'' section for more information.

\medskip
\texttt{[depends]}: 控制任务之间的依赖关系。 有关更多信息，请参阅 \bbgls{DEPENDS} 变量和 ``\bbsection{Inter-Task Dependencies}{任务间依赖关系}'' 部分。

\item \texttt{[deptask]}: Controls task build-time dependencies. See the \bbgls{DEPENDS} variable and the ``\bbsection{Build Dependencies}'' section for more information.

\medskip
\texttt{[deptask]}: 控制构建时任务之间的依赖关系。 有关更多信息，请参阅 \bbgls{DEPENDS} 变量和 ``\bbsection{Build Dependencies}{构建依赖项}'' 部分。

\item \texttt{[dirs]}: Directories that should be created before the task runs. Directories that already exist are left as is. The last directory listed is used as the current working directory for the task.

\medskip
\texttt{[dirs]}: 任务运行前应创建的目录。已存在的目录将保持不变。列表中列出的最后一个目录被用作任务的当前工作目录。.

\item \texttt{[file-checksums]}: Controls the file dependencies for a task. The baseline file list is the set of files associated with \bbgls{SRC_URI}. May be used to set additional dependencies on files not associated with \bbgls{SRC_URI}.

\medskip
\texttt{[file-checksums]}: 控制任务的各个文件之间的依赖关系。基线文件列表是与 \bbgls{SRC_URI} 相关联的文件集。此变量标志还可用于设置与 \bbgls{SRC_URI} 没有关联的文件的其他依赖关系。

\medskip
The value set to the list is a file-boolean pair where the first value is the file name and the second is whether or not it physically exists on the filesystem.

\medskip
设置为列表的值是一个文件名-布尔值的对值，其中第一个值是文件名，第二个值是它是否物理存在于文件系统上。

\medskip
\begin{pyglist}
do_configure[file-checksums] += "${MY_DIRPATH}/my-file.txt:True"
\end{pyglist}

\medskip
It is important to record any paths which the task looked at and which didn't exist. This means that if these do exist at a later time, the task can be rerun with the new additional files. The ``exists'' True or False value after the path allows this to be handled.

\medskip
记录任务已经查看过且不存在的任何路径非常重要。这意味着，如果这些路径稍后确实存在，则可以使用新的附加文件来重新运行任务。对值当中第二个用来表明路径是否``存在''的值是 True 还是 False 就是用来处理此问题。

\medskip
\item \texttt{[lockfiles]}: Specifies one or more lockfiles to lock while the task executes. Only one task may hold a lockfile, and any task that attempts to lock an already locked file will block until the lock is released. You can use this variable flag to accomplish mutual exclusion.

\medskip
\texttt{[lockfiles]}: 指定可以在任务执行时对任务进行锁定的一个或多个锁定文件。只有一个任务可以持有一个锁定文件，任何试图锁定已锁定文件的任务都会被阻止，直到此锁定被释放。你可以使用此变量标志来实现互斥操作。

\item \texttt{[network]}: When set to ``1'', allows a task to access the network. By default, only the \code{do_fetch} task is granted network access. Recipes shouldn't access the network outside of \code{do_fetch} as it usually undermines fetcher source mirroring, image and licence manifests, software auditing and supply chain security.

\medskip
\texttt{[network]}: 当此变量标志被设置为``1''时，允许任务访问网络。默认情况下，只有 \code{do_fetch} 任务被授予网络访问的权限。配方文件在除了 \code{do_fetch} 任务外，不应被允许访问外部网络，这样做的原因是因为这通常会消弱或者破坏源文件获取工具（fetcher）的源代码镜像、图像和许可证的清单、软件审计和供应链安全。

\item \texttt{[noexec]}: When set to ``1'', marks the task as being empty, with no execution required. You can use the \code{[noexec]} flag to set up tasks as dependency placeholders, or to disable tasks defined elsewhere that are not needed in a particular recipe.

\medskip
\texttt{[noexec]}: 当此变量标志被设置为“1”时，此任务将被标记为空任务，无需执行。你可以使用该 \code{[noexec]} 标志将任务设置为依赖项占位符，或在特定配方中禁用一些不需要的但是已经在其他地方定义的任务。

\item \texttt{[nostamp]}: When set to ``1'', tells BitBake to not generate a stamp file for a task, which implies the task should always be executed.

\medskip
\texttt{[nostamp]}: 当设置为“1”时，告诉 BitBake 不要为任务生成戳记文件，这意味着该任务在每次构建的时间都会被执行。

\medskip
\begin{noteblock}{Caution}%
Any task that depends (possibly indirectly) on a \code{[nostamp]} task will always be executed as well. This can cause unnecessary rebuilding if you are not careful.

\medskip
任何依赖于（可能间接地依赖于）被标记为 [nostamp] 任务的任务也总是会被执行。如果你不小心错误使用了此变量标记，这可能会导致不必要的重建工作。
\end{noteblock}

\item \texttt{[number\_threads]}: Limits tasks to a specific number of simultaneous threads during execution. This varflag is useful when your build host has a large number of cores but certain tasks need to be rate-limited due to various kinds of resource constraints (e.g. to avoid network throttling). \code{number_threads} works similarly to the \bbgls{BB_NUMBER_THREADS} variable but is task-specific.

\medskip
\texttt{[number\_threads]}: 限制任务在执行期间只能使用特定数量的同步线程。当你的构建主机具有很多CPU核但由于各种资源限制（例如为了避免网络节流）而需要限制某些任务的速率时，此变量标志（varflag）就会变得非常有用。变量 \code{number_threads} 的工作原理类似于 \bbgls{BB_NUMBER_THREADS} 变量，但是只适用于特定的某一项任务。

\medskip
Set the value globally. For example, the following makes sure the \code{do_fetch} task uses no more than two simultaneous execution threads: \code{do_fetch[number_threads] = "2"}

\medskip
该变量值的设置是是全局性的。例如，以下代码确保任务 \code{do_fetch} 使用不超过两个同步执行的线程：\code{do_fetch[number_threads] = “2”}

\medskip
\begin{noteblock}{Warning}%
\begin{itemize}
\setlength\itemsep{1.0em}
\item Setting the varflag in individual recipes rather than globally can result in unpredictable behavior.

\medskip
只在单独的配方中而不是全局性的设置此变量标志（varflag）可能会导致不可预测的行为。

\item Setting the varflag to a value greater than the value used in the \bbgls{BB_NUMBER_THREADS} variable causes \code{number_threads} to have no effect.

\medskip
将此变量标志（varflag）的值设置为大于 \bbgls{BB_NUMBER_THREADS} 变量中使用的值会导致 \code{number_threads} 不起作用。
\end{itemize}
\end{noteblock}

\item \texttt{[postfuncs]}: List of functions to call after the completion of the task.

\medskip
\texttt{[postfuncs]}：任务完成后要调用的函数列表。

\item \texttt{[prefuncs]}: List of functions to call before the task executes.

\medskip
\texttt{[prefuncs]}：任务执行前要调用的函数列表。

\item \texttt{[rdepends]}: Controls inter-task runtime dependencies. See the \bbgls{RDEPENDS} variable, the \bbgls{RRECOMMENDS} variable, and the ``\bbsection{Inter-Task Dependencies}'' section for more information.

\medskip
\texttt{[rdepends]}：控制软件包在运行时与其他软件包的依赖关系。 有关更多信息，请参阅 \bbgls{RDEPENDS} 变量、 \bbgls{RRECOMMENDS} 变量和``\bbsections{Inter-Task Dependencies}{任务间依赖关系}'' 部分。

\item \texttt{[rdeptask]}: Controls task runtime dependencies. See the \bbgls{RDEPENDS} variable, the \bbgls{RRECOMMENDS} variable, and the ``\bbsection{Runtime Dependencies}'' section for more information.

\medskip
\texttt{[rdeptask]}：控制任务运行时的依赖项。 有关更多信息，请参阅 \bbgls{RDEPENDS} 变量、 \bbgls{RRECOMMENDS} 变量和``\bbsections{Runtime Dependencies}{运行时依赖项}'' 部分。

\item \texttt{[recideptask]}: When set in conjunction with recrdeptask, specifies a task that should be inspected for additional dependencies.

\medskip
\texttt{[recideptask]}：在与 \code{recrdeptask} 一起设置时，用来指定要额外检查的用于发现其他的依赖项的任务。

\item \texttt{[recrdeptask]}: Controls task recursive runtime dependencies. See the \bbgls{RDEPENDS} variable, the \bbgls{RRECOMMENDS} variable, and the ``\bbsection{Recursive Dependencies}'' section for more information.

\medskip
\texttt{[recrdeptask]}：控制任务递归运行时的依赖关系。有关更多信息，请参阅 \bbgls{RDEPENDS} 变量、 \bbgls{RRECOMMENDS} 变量和 ``\bbsections{Recursive Dependencies}{递归依赖关系}'' 部分。

\item \texttt{[stamp-extra-info]}: Extra stamp information to append to the task's stamp. As an example, OpenEmbedded uses this flag to allow machine-specific tasks.

\medskip
\texttt{[stamp-extra-info]}：附加到任务标记的额外标记信息。例如，OpenEmbedded 使用此标志来允许某些只适用于特定目标机器的任务。

\item \texttt{[umask]}: The umask to run the task under.

\medskip
\texttt{[umask]}：设置运行任务的 umask\footnotemark[1]。

\footnotetext[1]{\code{umask} 用来控制 BitBake 任务所创建的文件和目录的权限。默认 \code{umask} 为 022，这意味着新文件和目录将分别以权限 644 和 755 进行创建。参见\bbgls{BB_DEFAULT_UMASK}}

\end{itemize}

Several varflags are useful for controlling how signatures are calculated for variables. For more information on this process, see the ``\bbsection{Checksums (Signatures)}'' section.

还有几个变量标志（varflag）可用于控制如何计算变量的签名。有关此过程的更多信息，请参阅 ``\bbsection{Checksums (Signatures)}{校验和（签名）}'' 部分。

\begin{itemize}
\setlength\itemsep{1.0em}
\item \texttt{[vardeps]}: Specifies a space-separated list of additional variables to add to a variable's dependencies for the purposes of calculating its signature. Adding variables to this list is useful, for example, when a function refers to a variable in a manner that does not allow BitBake to automatically determine that the variable is referred to.

\medskip
\texttt{[vardeps]}：用来指定一个由空格分隔的变量列表，这些变量将添加到变量的依赖项中，以便用来计算此变量的签名。将变量添加到此列表在一些情况下会很有用，比如当一个函数以不允许 BitBake 自动确定的引用变量的方式来引用此变量时，可以直接将此变量添加到 \code{vardeps} 列表中去。

\item \texttt{[vardepsexclude]}: Specifies a space-separated list of variables that should be excluded from a variable's dependencies for the purposes of calculating its signature.

\medskip
\texttt{[vardepsexclude]}：用来指定一个以空格分隔的变量列表，这些变量在计算其签名的时间，会被从此变量的依赖关系中排除掉。

\item \texttt{[vardepvalue]}: If set, instructs BitBake to ignore the actual value of the variable and instead use the specified value when calculating the variable's signature.

\medskip
\texttt{[vardepvalue]}：如果此值不为空，则意味着 BitBake 在计算变量的签名时将忽略变量的实际值，而是使用此处所指定的值。

\item \texttt{[vardepvalueexclude]}: Specifies a pipe-separated list of strings to exclude from the variable's value when calculating the variable's signature.

\medskip
\texttt{[vardepvalueexclude]}：用来指定一个以竖线分隔的字符串列表。这个列表中的值在计算变量的签名时将被从变量的值的列表中排除掉。

\end{itemize}

\newsection{Events}{事件}

BitBake allows installation of event handlers within recipe and class files. Events are triggered at certain points during operation, such as the beginning of operation against a given recipe (i.e. \code{*.bb}), the start of a given task, a task failure, a task success, and so forth. The intent is to make it easy to do things like email notification on build failures.

BitBake 允许在配方和类文件中安装事件处理程序。事件会在操作期间的某些点被触发，例如针对给定配方（即 \code{*.bb}）的启动操作、给定任务的开始操作、任务的失败通知、任务成功通知等。触发事件的目的是使构建失败时发送电子邮件通知等操作变得更简单。

Following is an example event handler that prints the name of the event and the content of the \bbgls{FILE} variable:

以下是一个事件处理程序的例子，用来打印事件名称和 \bbgls{FILE} 变量内容：

\begin{pyglist}
addhandler myclass_eventhandler
python myclass_eventhandler() {
    from bb.event import getName
    print("The name of the Event is %s" % getName(e))
    print("The file we run for is %s" % d.getVar('FILE'))
}
myclass_eventhandler[eventmask] = "bb.event.BuildStarted
bb.event.BuildCompleted"
\end{pyglist}

In the previous example, an eventmask has been set so that the handler only sees the ``BuildStarted'' and ``BuildCompleted'' events. This event handler gets called every time an event matching the eventmask is triggered. A global variable ``e'' is defined, which represents the current event. With the \code{getName(e)} method, you can get the name of the triggered event. The global datastore is available as ``d''. In legacy code, you might see ``e.data'' used to get the datastore. However, realize that ``e.data'' is deprecated and you should use ``d'' going forward.

在上例中，事件的掩码 \code{eventmask} 已经设置好了，以便事件处理程序仅仅能看到 ``BuildStarted'' 和 ``BuildCompleted'' 这两个事件。每次触发与事件掩码匹配的事件时，此事件处理程序都会被调用。同时，此例子也定义了一个全局变量 ``e''，它用来表示当前事件。使用 \code{getName(e)} 方法，你可以获取触发事件的名称。全局数据存储区可用 ``d'' 变量来表示。在旧版本的代码中，你可能会看到用于获取数据存储区的变量是用 ``e.data'' 来表示的。但是，请注意 ``e.data'' 已在新版本中被弃用了，应该从现在起使用 ``d'' 变量来表示。

The context of the datastore is appropriate to the event in question. For example, ``BuildStarted'' and ``BuildCompleted'' events run before any tasks are executed so would be in the global configuration datastore namespace. No recipe-specific metadata exists in that namespace. The ``BuildStarted'' and ``BuildCompleted'' events also run in the main cooker/server process rather than any worker context. Thus, any changes made to the datastore would be seen by other cooker/server events within the current build but not seen outside of that build or in any worker context. Task events run in the actual tasks in question consequently have recipe-specific and task-specific contents. These events run in the worker context and are discarded at the end of task execution.

数据存储的内容都是与相关事件相适合的。例如，``BuildStarted'' 和 ``BuildCompleted'' 这两个事件都是在执行任何任务之前运行的，因此它们都将位于全局配置数据存储命名空间中。该命名空间中不存在与特定配方相关的元数据。``BuildStarted'' 和 ``BuildCompleted'' 事件也在主 cooker/server 进程中运行，而不是在任何 worker 进程中运行。因此，对数据存储所做的任何更改都会被当前构建中的其他 cooker/server 事件看到，但在该构建之外或任何 worker 进程的上下文中都看不到。因此，在实际的相关任务中运行的任务事件拥有与特定配方和特点任务相关的内容。这些事件在 worker 进程中运行，并在任务执行结束时被丢弃。

During a standard build, the following common events might occur. The following events are the most common kinds of events that most metadata might have an interest in viewing:

在标准构建过程中，可能会发生以下的常见事件。以下事件是大多数元数据可能有兴趣查看的最常见的事件类型：

\begin{itemize}
\setlength\itemsep{1.0em}
\item \texttt{bb.event.ConfigParsed()}: Fired when the base configuration; which consists of \code{bitbake.conf}, \code{base.bbclass} and any global \bbgls{INHERIT} statements; has been parsed. You can see multiple such events when each of the workers parse the base configuration or if the server changes configuration and reparses. Any given datastore only has one such event executed against it, however. If \bbgls{BB_INVALIDCONF} is set in the datastore by the event handler, the configuration is reparsed and a new event triggered, allowing the metadata to update configuration.

\medskip
\texttt{bb.event.ConfigParsed()}：当由 \code{bitbake.conf}，\code{base.bbclass}，任何全局 \code{INHERIT}语句所组成的基本配置已经被解析的时间触发。当每个工作程序解析了基本配置或服务器更改配置并重新解析时，此类事件可以被多次触发。但是，任何给定的数据存储区都只会对其此类事件执行一次处理程序。如果事件处理程序在数据存储区中对变量 \bbgls{BB_INVALIDCONF} 进行设置，BitBake则会重新解析构建配置并对此事件进行重新触发，从而允许元数据来更新配置。

\item \texttt{bb.event.HeartbeatEvent()}: Fires at regular time intervals of one second. You can configure the interval time using the \code{BB_HEARTBEAT_EVENT} variable. The event's ``time'' attribute is the \code{time.time()} value when the event is triggered. This event is useful for activities such as system state monitoring.

\medskip
\texttt{bb.event.HeartbeatEvent()}：以一秒为间隔的定期触发事件。你可以使用变量  \code{BB_HEARTBEAT_EVENT} 来配置间隔时间。事件的 ``time'' 属性值是 \code{time.time()}, 也就是触发事件时的时间值。此事件对于监控系统状态等活动很有用。

\item \texttt{bb.event.ParseStarted()}: Fired when BitBake is about to start parsing recipes. This event's ``total'' attribute represents the number of recipes BitBake plans to parse.

\medskip
\texttt{bb.event.ParseStarted()}：当 BitBake 即将开始解析配方时被触发。此事件的 ``total'' 属性用来表示 BitBake 计划解析的配方的数量。

\item \texttt{bb.event.ParseProgress()}: Fired as parsing progresses. This event's ``current'' attribute is the number of recipes parsed as well as the ``total'' attribute.

\medskip
\texttt{bb.event.ParseProgress()}：在解析过程中触发。此事件的 ``current'' 属性和 ``total'' 属性都是 BitBke 要解析的配方数量。

\item \texttt{bb.event.ParseCompleted()}: Fired when parsing is complete. This event's ``cached'', ``parsed'', ``skipped'', ``virtuals'', ``masked'', and ``errors'' attributes provide statistics for the parsing results.

\medskip
\texttt{bb.event.ParseCompleted()}：在解析完成时触发。此事件的 ``cached''、``parsed''、``skipped''、``virtuals''、``masked'' 和 ``errors'' 属性值可以用来提供了解析结果的统计信息。

\item \texttt{bb.event.BuildStarted()}: Fired when a new build starts. BitBake fires multiple ``BuildStarted'' events (one per configuration) when multiple configuration (multiconfig) is enabled.

\medskip
\texttt{bb.event.BuildStarted()}：当新构建开始时的时间触发。启用多个配置 (multiconfig) 时，BitBake 会触发多个 ``BuildStarted'' 事件（每个配置都会触发一个相同的事件）。

\item \texttt{bb.build.TaskStarted()}: Fired when a task starts. This event's ``taskfile'' attribute points to the recipe from which the task originates. The ``taskname'' attribute, which is the task's name, includes the \code{do_ prefix}, and the ``logfile'' attribute point to where the task's output is stored. Finally, the ``time'' attribute is the task's execution start time.

\medskip
\texttt{bb.build.TaskStarted()}：当任务启动时触发。此事件的 ``taskfile'' 属性指向任务的来源配方。``taskname'' 属性是任务的名称，名称中包含了前缀 \code{do_}，``logfile''属性指向任务输出日志文件的存储位置。最后，``time'' 属性是任务的执行开始时间。

\item \texttt{bb.build.TaskInvalid()}: Fired if BitBake tries to execute a task that does not exist.

\medskip
\texttt{bb.build.TaskInvalid()}：在 BitBake 尝试执行一个不存在的任务的时间触发。

\item \texttt{bb.build.TaskFailedSilent()}: Fired for setscene tasks that fail and should not be presented to the user verbosely.

\medskip
\texttt{bb.build.TaskFailedSilent()}：因设置场景任务失败而触发，次事件不应该向用户展示详细的信息。

\item \texttt{bb.build.TaskFailed()}: Fired for normal tasks that fail.

\medskip
\texttt{bb.build.TaskFailed()}：因正常任务失败而触发。

\item \texttt{bb.build.TaskSucceeded()}: Fired when a task successfully completes.

\medskip
\texttt{bb.build.TaskSucceeded()}：当任务成功完成时触发。

\item \texttt{bb.event.BuildCompleted()}: Fired when a build finishes.

\medskip
\texttt{bb.event.BuildCompleted()}：当构建完成时触发。

\item \texttt{bb.cooker.CookerExit()}: Fired when the BitBake server/cooker shuts down. This event is usually only seen by the UIs as a sign they should also shutdown.

\medskip
\texttt{bb.cooker.CookerExit()}：当 BitBake 的 server/cooker 关闭时触发。此事件通常仅被 UI 视为它们也应该关闭的标志。

\end{itemize}

This next list of example events occur based on specific requests to the server. These events are often used to communicate larger pieces of information from the BitBake server to other parts of BitBake such as user interfaces:

下一个示例事件列表基于对服务器的特定请求而发生。这些事件通常用于将较大的信息从 BitBake 服务器传达到 BitBake 的其他部分（例如用户界面）：

\begin{itemize}
\setlength\itemsep{1.0em}
\item \texttt{bb.event.TreeDataPreparationStarted()}

\item \texttt{bb.event.TreeDataPreparationProgress()}

\item \texttt{bb.event.TreeDataPreparationCompleted()}

\item \texttt{bb.event.DepTreeGenerated()}

\item \texttt{bb.event.CoreBaseFilesFound()}

\item \texttt{bb.event.ConfigFilePathFound()}

\item \texttt{bb.event.FilesMatchingFound()}

\item \texttt{bb.event.ConfigFilesFound()}

\item \texttt{bb.event.TargetsTreeGenerated()}
\end{itemize}

\newsection{Variants — Class Extension Mechanism}{变体—类的扩展机制}

BitBake supports multiple incarnations of a recipe file via the \bbgls{BBCLASSEXTEND} variable.

BitBake 通过对 \bbgls{BBCLASSEXTEND} 变量的设置来支持配方文件的多种形式 。

The \bbgls{BBCLASSEXTEND} variable is a space separated list of classes used to ``extend'' the recipe for each variant. Here is an example that results in a second incarnation of the current recipe being available. This second incarnation will have the ``native'' class inherited.

\bbgls{BBCLASSEXTEND} 变量是一个以空格来分隔的类的列表，用于对列表中的每个变体来对原有配方进行``扩展''。下面的示例会导致当前配方有第二个变体配方可用。第二个变体配方将会继承 ``native'' 类。

\begin{pyglist}
BBCLASSEXTEND = "native"
\end{pyglist}

\begin{noteblock}{Note}%
The mechanism for this class extension is extremely specific to the implementation. Usually, the recipe's \bbgls{PROVIDES}, \bbgls{PN} , and \bbgls{DEPENDS} variables would need to be modified by the extension class. For specific examples, see the OE-Core \href{https://docs.yoctoproject.org/ref-manual/classes.html#native}{native},\href{https://docs.yoctoproject.org/ref-manual/classes.html#nativesdk}{nativesdk} and \href{https://docs.yoctoproject.org/ref-manual/classes.html#multilib}{multilib} classes.

\medskip
这种对类进行扩展的机制是取决于具体的实现。通常来讲，配方的 \bbgls{PROVIDES}、\bbgls{PN} 和 \bbgls{DEPENDS} 变量都需要由扩展类来进行修改。相关的具体示例，请参阅 OE-Core \href{https://docs.yoctoproject.org/ref-manual/classes.html#native}{native}、\href{https://docs.yoctoproject.org/ref-manual/classes.html#nativesdk}{nativesdk} 和 \href{https://docs.yoctoproject.org/ref-manual/classes.html#multilib}{multilib} 类。


\end{noteblock}

\newsection{Dependencies}{依赖项}
\label{section:Dependencies}

To allow for efficient parallel processing, BitBake handles dependencies at the task level. Dependencies can exist both between tasks within a single recipe and between tasks in different recipes. Following are examples of each:

为了实现高效的并行处理，BitBake 是在任务级别上来处理依赖关系的。依赖关系既可以存在于单个配方内的任务之间，也可以存在于不同配方中的任务之间。以下是每个情况的示例：

\begin{itemize}
\setlength\itemsep{1.0em}
\item For tasks within a single recipe, a recipe's \code{do_configure} task might need to complete before its \code{do_compile} task can run.

\medskip
对于单个配方内的任务，配方的 \code{do_configure} 任务可能需要先完成，然后其 \code{do_compile} 任务才能运行。

\item For tasks in different recipes, one recipe's \code{do_configure} task might require another recipe's \code{do_populate_sysroot} task to finish first such that the libraries and headers provided by the other recipe are available.

\medskip
对于不同配方中的任务，一个配方的 \code{do_configure} 任务可能需要另一个配方的 \code{do_populate_sysroot} 任务先完成，以便此配方能够提供前一个配方所需要的库和头文件。
\end{itemize}

This section describes several ways to declare dependencies. Remember, even though dependencies are declared in different ways, they are all simply dependencies between tasks.

本节介绍了几种声明依赖项的方法。请记住，尽管依赖项声明的方式各有不同，但它们都只是用来表明任务之间的依赖关系而已。

\newsubsection{Dependencies Internal to the \texttt{.bb} File}{\texttt{.bb} 文件内部的依赖关系}

BitBake uses the \code{addtask} directive to manage dependencies that are internal to a given recipe file. You can use the \code{addtask} directive to indicate when a task is dependent on other tasks or when other tasks depend on that recipe. Here is an example:

BitBake 使用 \code{addtask} 指令来管理指定的配方文件内部的依赖关系。你可以使用 \code{addtask} 指令来指示任务何时需要依赖于其他任务，或者其他任务何时需要依赖于该配方。参见下面的例子：

\begin{pyglist}
addtask printdate after do_fetch before do_build
\end{pyglist}

In this example, the \code{do_printdate} task depends on the completion of the \code{do_fetch} task, and the \code{do_build} task depends on the completion of the \code{do_printdate} task.

在这个例子中，\code{do_printdate} 任务依赖于 \code{do_fetch} 任务的完成，而 \code{do_build} 任务则依赖于 \code{do_printdate} 任务的完成。

\begin{noteblock}{Note}%

For a task to run, it must be a direct or indirect dependency of some other task that is scheduled to run.

\medskip
要运行某个任务，它必须直接或间接依赖于其他计划运行的任务。

\medskip
For illustration, here are some examples:

\medskip
以下是一些用于说明的示例：

\begin{itemize}
\setlength\itemsep{1.0em}

\item The directive \code{addtask mytask before do_configure} causes \code{do_mytask} to run before \code{do_configure} runs. Be aware that \code{do_mytask} still only runs if its \bbsections{Checksums (Signatures)}{input checksum} has changed since the last time it was run. Changes to the input checksum of \code{do_mytask} also indirectly cause \code{do_configure} to run.

\medskip
该指令 \code{addtask mytask before do_configure} 会导致 \code{do_mytask} 在 \code{do_configure} 运行之前先运行。请注意，仅当其 \bbsections{Checksums (Signatures)}{输入校验和} 自上次运行以来发生变化时，\code{do_mytask} 任务才会运行。对  \code{do_mytask} 输入校验和的更改也会间接导致 \code{do_configure} 任务被再次运行。

\item The directive \code{addtask mytask after do_configure} by itself never causes \code{do_mytask} to run. \code{do_mytask} can still be run manually as follows:

\medskip
该指令 \code{addtask mytask after do_configure} 本身不会导致 \code{do_mytask} 任务自动运行。但是仍然可以按如下方式来手动运行 \code{do_mytask} 任务：

\medskip
\begin{pyglist}
$ bitbake recipe -c mytask
\end{pyglist}

\medskip
Declaring \code{do_mytask} as a dependency of some other task that is scheduled to run also causes it to run. Regardless, the task runs after \code{do_configure}.

\medskip
声明 \code{do_mytask} 任务为其他计划运行的任务的依赖项也会导致其运行。无论如何，该任务是在 \code{ do_configure} 任务之后运行。
\end{itemize}
\end{noteblock}

\newsubsection{Build Dependencies}{构建依赖项}
\label{section:Build Dependencies}

BitBake uses the \bbgls{DEPENDS} variable to manage build time dependencies. The \code{[deptask]} varflag for tasks signifies the task of each item listed in \bbgls{DEPENDS} that must complete before that task can be executed. Here is an example:

BitBake 使用 \bbgls{DEPENDS} 变量来管理构建时的依赖项。任务的变量标志 \code{[deptask]} 用来表示 \bbgls{DEPENDS} 变量中列出的每项任务必须先完成，然后才能执行该任务。以下是一个示例：

\begin{pyglist}
do_configure[deptask] = "do_populate_sysroot"
\end{pyglist}

In this example, the \code{do_populate_sysroot} task of each item in \bbgls{DEPENDS} must complete before \code{do_configure} can execute.

在这个例子中，\bbgls{DEPENDS} 变量中所列出的每个项目的 \code{do_populate_sysroot} 任务都必须在 \code{do_configure} 任务之前执行完成。

\newsubsection{Runtime Dependencies}{运行时依赖项}
\label{section:Runtime Dependencies}
BitBake uses the \bbgls{PACKAGES}, \bbgls{RDEPENDS} and \bbgls{RRECOMMENDS} variables to manage runtime dependencies.

BitBake 使用 \bbgls{PACKAGES}，\bbgls{RDEPENDS} 和 \bbgls{RRECOMMENDS} 变量来管理运行时的依赖项。

The \bbgls{PACKAGES} variable lists runtime packages. Each of those packages can have \bbgls{RDEPENDS} and \bbgls{RRECOMMENDS} runtime dependencies. The \code{[rdeptask]} flag for tasks is used to signify the task of each item runtime dependency which must have completed before that task can be executed.

\bbgls{PACKAGES} 变量列出了运行时所需要的包。每个包都可以有 \bbgls{RDEPENDS} 和 \bbgls{RRECOMMENDS} 变量所定义的运行时的依赖项。 任务标志 [rdeptask] 用于表示每个项目运行时其依赖项的任务所依赖的任务，该依赖任务必须先完成，然后才能执行该任务。

\begin{pyglist}
do_package_qa[rdeptask] = "do_packagedata"
\end{pyglist}

In the previous example, the \code{do_packagedata} task of each item in \bbgls{RDEPENDS} must have completed before \code{do_package_qa} can execute. Although \bbgls{RDEPENDS} contains entries from the runtime dependency namespace, BitBake knows how to map them back to the build-time dependency namespace, in which the tasks are defined.

在上面的示例中，\bbgls{RDEPENDS} 变量中的每一项的 \code{do_packagedata} 任务必须先完成才能执行 \code{do_package_qa} 任务。尽管 \bbgls{RDEPENDS} 包含来自运行时依赖项的命名空间的条目，但 BitBake 知道如何将它们映射回构建时的依赖项的命名空间内的任务，这些任务都是在这个命名空间来定义的。

\newsubsection{Recursive Dependencies}{递归依赖}
\label{section:Recursive Dependencies}

BitBake uses the \code{[recrdeptask]} flag to manage recursive task dependencies. BitBake looks through the build-time and runtime dependencies of the current recipe, looks through the task's inter-task dependencies, and then adds dependencies for the listed task. Once BitBake has accomplished this, it recursively works through the dependencies of those tasks. Iterative passes continue until all dependencies are discovered and added.

BitBake 使用 \code{[recrdeptask]} 标志来管理递归任务依赖关系。BitBake 查看当前配方的构建时和运行时依赖关系，再查看任务的任务间依赖关系，然后为列出的任务添加依赖关系。BitBake 完成此操作后，它会递归地处理这些任务的依赖关系。迭代过程会持续进行，直到所有的依赖关系都被发现并被添加到本地的数据存储里面。

The \code{[recrdeptask]} flag is most commonly used in high-level recipes that need to wait for some task to finish ``globally''. For example, \code{image.bbclass} has the following:

该 \code{[recrdeptask]} 标志最常用于需要等待某些任务“全局性”的完成的高级配方。例如， \code{image.bbclass} 具有以下内容：
\begin{pyglist}
do_rootfs[recrdeptask] += "do_packagedata"
\end{pyglist}

This statement says that the \code{do_packagedata} task of the current recipe and all recipes reachable (by way of dependencies) from the image recipe must run before the \code{do_rootfs} task can run.

该语句表示，当前此 \code{image} 配方以及从此配方（通过依赖关系）可到达的所有配方必须先运行其 \code{do_packagedata} 任务，然后其 \code{do_rootfs} 任务才能运行。

BitBake allows a task to recursively depend on itself by referencing itself in the task list:

BitBake 允许任务通过在任务列表中引用自身来递归地依赖自身：

\begin{pyglist}
do_a[recrdeptask] = "do_a do_b"
\end{pyglist}

In the same way as before, this means that the \code{do_a} and \code{do_b} tasks of the current recipe and all recipes reachable (by way of dependencies) from the recipe must run before the \code{do_a} task can run. In this case BitBake will ignore the current recipe's \code{do_a} task circular dependency on itself.

与之前的例子一样，这意味着当前配方和从此配方中所有可到达的配方（通过依赖关系）的 \code{do_a} 任务he \code{do_b} 任务必须先运行，然后 \code{do_a} 任务才能运行。在这种情况下，BitBake 将忽略当前配方 \code{do_a} 对自身的任务循环依赖。

\newsubsection{Inter-Task Dependencies}{任务间依赖关系}
\label{section:Inter-Task Dependencies}

BitBake uses the \code{[depends]} flag in a more generic form to manage inter-task dependencies. This more generic form allows for inter-dependency checks for specific tasks rather than checks for the data in \bbgls{DEPENDS}. Here is an example:

BitBake 会以更通用的形式使用该 \code{[depends]} 标志来管理任务间的依赖关系。这种更通用的形式允许对特定任务进行相互依赖性检查，而不是检查 \bbgls{DEPENDS} 中的数据。参见下面的例子：

\begin{pyglist}
do_patch[depends] = "quilt-native:do_populate_sysroot"
\end{pyglist}

In this example, the \code{do_populate_sysroot} task of the target \code{quilt-native} must have completed before the \code{do_patch} task can execute.

在这个例子中，构建目标 \code{quilt-native} 的 \code{do_populate_sysroot} 任务必须已经完成，然后 \code{do_patch} 任务才能执行。

The [rdepends] flag works in a similar way but takes targets in the runtime namespace instead of the build-time dependency namespace.

该 \code{[rdepends]} 标志的工作方式与前面提到的 \code{rdeptask} 类似，但是其采用的是运行时命名空间中的目标，而不是构建时的依赖相命名空间。

\newsection{Functions You Can Call From Within Python}{可以从 Python 内部调用的函数}
\label{section:Functions You Can Call From Within Python}
BitBake provides many functions you can call from within Python functions. This section lists the most commonly used functions, and mentions where to find others.

BitBake 提供了许多可从 Python 函数中调用的函数。本节列出了最常用的函数，并提到了在哪里可以找到其他函数。

\newsubsection{Functions for Accessing Datastore Variables}{访问数据存储区变量的函数}
\label{section:Functions for Accessing Datastore Variables}

It is often necessary to access variables in the BitBake datastore using Python functions. The BitBake datastore has an API that allows you this access. Here is a list of available operations:

通常需要使用 Python 函数访问 BitBake 数据存储中的变量。BitBake 数据存储提供了一个 API 允许你进行此访问。以下是可用操作的列表：

\begin{center}
    \rowcolors{1}{}{codebggreay}
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
\textbf{Operation} & \textbf{Description}\\ \hline
\code{d.getVar("X", expand)} & Returns the value of variable ``X''. Using ``expand=True'' expands the value. Returns ``None'' if the variable ``X'' does not exist. \\ \hline
\code{d.setVar("X", "value")} & Sets the variable ``X'' to ``value''  \\ \hline
\code{d.appendVar("X", "value")} & Adds ``value'' to the end of the variable ``X''. Acts like d.setVar("X", "value") if the variable ``X'' does not exist.  \\ \hline
\code{d.prependVar("X", "value")} & Adds ``value'' to the start of the variable ``X''. Acts like d.setVar("X","value") if the variable ``X'' does not exist.  \\ \hline
\code{d.delVar("X")} & Deletes the variable ``X'' from the datastore. Does nothing if the variable ``X'' does not exist. \\ \hline
\code{d.renameVar("X", "Y")} & Renames the variable ``X'' to ``Y''. Does nothing if the variable ``X'' does not exist.  \\ \hline
\code{d.getVarFlag("X", flag, expand)} & Returns the value of variable ``X''. Using ``expand=True'' expands the value. Returns ``None'' if either the variable ``X'' or the named flag does not exist.  \\ \hline
\code{d.setVarFlag("X", flag, "value")} & Sets the named flag for variable ``X'' to ``value''. \\ \hline
\code{d.appendVarFlag("X", flag, "value")} & Appends ``value'' to the named flag on the variable ``X''. Acts like d.setVarFlag("X", flag, "value") if the named flag does not exist.  \\ \hline
\code{d.prependVarFlag("X", flag, "value")} & Prepends ``value'' to the named flag on the variable ``X''. Acts like d.setVarFlag("X", flag, "value") if the named flag does not exist.  \\ \hline
\code{d.delVarFlag("X", flag)} & Deletes the named flag on the variable ``X'' from the datastore.  \\ \hline
\code{d.setVarFlags("X", flagsdict)} & Sets the flags specified in the flagsdict() parameter. setVarFlags does not clear previous flags. Think of this operation as addVarFlags.  \\ \hline
\code{d.getVarFlags("X")} & Returns a flagsdict of the flags for the variable ``X''. Returns ``None'' if the variable ``X'' does not exist.  \\ \hline
\code{d.delVarFlags("X")} & Deletes all the flags for the variable ``X''. Does nothing if the variable ``X'' does not exist.  \\ \hline
\code{d.expand(expression)} & Expands variable references in the specified string expression. References to variables that do not exist are left as is. For example, \code{d.expand("foo ${X}")} expands to the literal string ``\code{foo ${X}}'' if the variable ``X'' does not exist.  \\ \hline
\end{tabular}
\end{center}

\bigskip

\begin{center}
    \rowcolors{1}{}{codebggreay}
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
\textbf{操作} & \textbf{操作的描述}\\ \hline
\code{d.getVar("X", expand)} & 返回变量``X''的值。使用``expand=True''可扩展该值。如果变量``X''不存在，则返回``None''。\\ \hline
\code{d.setVar("X", "value")} & 将变量``X''设置为``value''。 \\ \hline
\code{d.appendVar("X", "value")} & 在变量``X''的末尾添加``value''。如果变量``X''不存在，则如同调用 \code{d.setVar("X", "value")}。\\ \hline
\code{d.prependVar("X", "value")} & 将“value”添加到变量“X”的开头。如果变量​​“X”不存在一样，则如同调用 \code{d.setVar("X", "value")}。\\ \hline
\code{d.delVar("X")} & 从数据存储中删除变量``X''。如果变量``X''不存在，则不执行任何操作。\\ \hline
\code{d.renameVar("X", "Y")} & 将变量``X''重命名为``Y''。如果变量``X''不存在，则不执行任何操作。\\ \hline
\code{d.getVarFlag("X", flag, expand)} & 返回变量``X''的变量标志flag的值。使用``expand=True''可扩展该值。如果变量``X''或变量标志``flag''不存在，则返回``None''。\\ \hline
\code{d.setVarFlag("X", flag, "value")} & 将变量``X''的变量标志``flag''设置为``value''。\\ \hline
\code{d.appendVarFlag("X", flag, "value")} & 将``value''附加到变量``X''的变量标志``flag''上。 如果变量标志不存在，则执行操作 \code{d.setVarFlag("X", flag, "value")}。\\ \hline
\code{d.prependVarFlag("X", flag, "value")} & 将``value''添加到变量``X''的变量标志``flag''上。 如果变量标志不存在，则执行操作 \code{d.setVarFlag("X", flag, "value")}。\\ \hline
\code{d.delVarFlag("X", flag)} & 从数据存储区中删除变量``X''的变量标志``flag''。\\ \hline
\code{d.setVarFlags("X", flagsdict)} & 设置变量``X''的变量标志为参数\code{flagsdict()}。\code{setVarFlags}不会清除以前的标志。可以将此操作视为\code{addVarFlags}。\\ \hline
\code{d.getVarFlags("X")} & 返回变量``X''的变量标志\code{flagsdict}。如果变量``X''不存在，则返回``None''。\\ \hline
\code{d.delVarFlags("X")} & 删除变量``X''的所有标志。如果变量``X''不存在，则不执行任何操作。\\ \hline
\code{d.expand(expression)} & 扩展指定字符串\code{expression}中的变量引用。对不存在的变量的引用将保持原样。例如，\code{d.expand("foo ${X}")}，如果变量``X''不存在，则扩展为文字字符串“\code{foo ${X}}”。\\ \hline
\end{tabular}
\end{center}

\newsubsection{Other Functions}{其他函数}

You can find many other functions that can be called from Python by looking at the source code of the bb module, which is in \code{bitbake/lib/bb}. For example, \code{bitbake/lib/bb/utils.py} includes the commonly used functions \code{bb.utils.contains()} and \code{bb.utils.mkdirhier()}, which come with docstrings.

通过查看模块的源代码，你可以找到许多其他可以从 Python 调用的函数，这些函数位于 \code{bitbake/lib/bb} 目录中。例如，\code{bitbake/lib/bb/utils.py} 包括了常用函数\code{bb.utils.contains()} 和 \code{bb.utils.mkdirhier()}，它们都附带了说明文档。

\newsubsection{Extending Python Library Code}{扩展 Python 库代码}
\label{section:Extending Python Library Code}

If you wish to add your own Python library code (e.g. to provide functions/classes you can use from Python functions in the metadata) you can do so from any layer using the \code{addpylib} directive. This directive is typically added to your layer configuration ( \code{conf/layer.conf}) although it will be handled in any \code{.conf} file.

如果你希望添加自己的 Python 库代码（例如，提供可以从元数据中的 Python 函数中使用的函数/类等），你可以从任何层文件中执行此 \code{addpylib} 指令操作。尽管此指令可以被任何配置文件（\code{.conf}）所处理，但是通常还是添加到你自己的层的配置文件（ \code{conf/layer.conf}）中去，

Usage is of the form:

此指令的使用形式如下：

\begin{pyglist}
addpylib <directory> <namespace>
\end{pyglist}

Where <directory> specifies the directory to add to the library path. The specified <namespace> is imported automatically, and if the imported module specifies an attribute named \code{BBIMPORTS}, that list of sub-modules is iterated and imported too.

其中 \code{<directory>} 是用来指定要添加到库路径的目录。指定的 \code{<namespace>} 会被自动导入，如果导入的模块指定了名为 \code{BBIMPORTS} 的属性，则其所有子模块也会被导入。

\newsubsection{Testing and Debugging BitBake Python code}{测试和调试 BitBake Python 代码}

The OpenEmbedded build system implements a convenient pydevshell target which you can use to access the BitBake datastore and experiment with your own Python code. See \href{https://docs.yoctoproject.org/dev-manual/python-development-shell.html#using-a-python-development-shell}{Using a Python Development Shell} in the Yocto Project manual for details.

OpenEmbedded 构建系统实现了一个非常方便的构建目标名为\code{pydevshell}，你可以使用它来访问 BitBake 数据存储区并试验你自己的 Python 代码。有关详细信息，请参阅 Yocto 项目手册中的 \href{https://docs.yoctoproject.org/dev-manual/python-development-shell.html#using-a-python-development-shell}{Using a Python Development Shell} 。

\newsection{Task Checksums and Setscene}{任务校验和和场景设置}

\label{section:Task Checksums and Setscene}

BitBake uses checksums (or signatures) along with the setscene to determine if a task needs to be run. This section describes the process. To help understand how BitBake does this, the section assumes an OpenEmbedded metadata-based example.

BitBake 使用校验和（或签名）以及 setscene 来确定一个任务是否需要运行。本节将介绍这一过程。为了帮助理解 BitBake 如何执行此操作，本节假设了一个基于 OpenEmbedded 元数据的示例。

These checksums are stored in \bbgls{STAMP}. You can examine the checksums using the following BitBake command:

这些校验和都存储在 \bbgls{STAMP} 变量中。你可以使用下面的 BitBake 命令来检查校验和：

\begin{pyglist}
$ bitbake-dumpsigs
\end{pyglist}

This command returns the signature data in a readable format that allows you to examine the inputs used when the OpenEmbedded build system generates signatures. For example, using \code{bitbake-dumpsigs} allows you to examine the \code{do_compile} task's ``sigdata'' for a C application (e.g. \code{bash}). Running the command also reveals that the ``CC'' variable is part of the inputs that are hashed. Any changes to this variable would invalidate the stamp and cause the \code{do_compile} task to run.

此命令以可读格式返回签名数据，这些数据允许你检查 OpenEmbedded 构建系统在生成签名时所使用的输入参数。例如，使用 \code{bitbake-dumpsigs} 命令允许你检查 \code{do_compile} 任务给一个 C 应用程序（例如bash）所提供的 ``sigdata''。运行该命令还会显示 ``CC'' 变量是已经散列化的输入的一部分。对此变量的任何更改都将使标记无效并导致任务 \code{do_compile} 任务被重新运行。

The following list describes related variables:

下面列出了相关的变量：

\begin{itemize}
\setlength\itemsep{1.0em}
\item \bbgls{BB_HASHCHECK_FUNCTION}: Specifies the name of the function to call during the ``setscene'' part of the task's execution in order to validate the list of task hashes.

\medskip
\bbgls{BB_HASHCHECK_FUNCTION}: 指定在任务执行 ``setscene'' 部分期间调用的函数名称，这些函数是用来验证任务的哈希列表。

\item \bbgls{BB_SETSCENE_DEPVALID}: Specifies a function BitBake calls that determines whether BitBake requires a setscene dependency to be met.

\medskip
\bbgls{BB_SETSCENE_DEPVALID}: 给 BitBake 指定一个调用的函数名称，该函数用于确定 BitBake 是否需要 setscene 依赖关系被满足。

\item \bbgls{BB_TASKHASH}: Within an executing task, this variable holds the hash of the task as returned by the currently enabled signature generator.

\medskip
\bbgls{BB_TASKHASH}: 在执行任务中，此变量用于保存当前启用的签名生成器返回的任务哈希值。

\item \bbgls{STAMP}: The base path to create stamp files.

\medskip
\bbgls{STAMP}: 用于创建戳记文件的基本路径。

\item \bbgls{STAMPCLEAN}: Again, the base path to create stamp files but can use wildcards for matching a range of files for clean operations.

\medskip
\bbgls{STAMPCLEAN}: 同样，用于创建戳记文件的基本路径，但可以使用通配符来匹配一系列文件以进行清理操作。
\end{itemize}

\newsection{Wildcard Support in Variables}{变量中的通配符匹配}

Support for wildcard use in variables varies depending on the context in which it is used. For example, some variables and filenames allow limited use of wildcards through the ``\%'' and ``*'' characters. Other variables or names support Python's \href{https://docs.python.org/3/library/glob.html}{glob} syntax, \href{https://docs.python.org/3/library/fnmatch.html#module-fnmatch}{fnmatch} syntax, or \href{https://docs.python.org/3/library/re.html}{Regular Expression (re)} syntax.

变量中对通配符的使用支持是取决于使用通配符的上下文。例如，某些变量和文件名允许通过 ``\%'' 和 ``*'' 字符有限地使用通配符。其他变量或名称都支持 Python 的 \href{https://docs.python.org/3/library/glob.html}{glob} 语法、\href{https://docs.python.org/3/library/fnmatch.html#module-fnmatch}{fnmatch} 语法或 \href{https://docs.python.org/3/library/re.html}{正则表达式 (re)} 语法。

For variables that have wildcard suport, the documentation describes which form of wildcard, its use, and its limitations.

对于具有通配符支持的变量，这些文档描述了通配符的形式、用途以及对其使用的限制。
